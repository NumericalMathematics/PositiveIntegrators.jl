var documenterSearchIndex = {"docs":
[{"location":"stratospheric_reaction_benchmark/#benchmark-stratos","page":"Stratospheric reaction problem","title":"Benchmark: Solution of a stratospheric reaction problem","text":"We use the stiff stratospheric reaction problem prob_pds_stratreac to assess the efficiency of different solvers from OrdinaryDiffEq.jl and PositiveIntegrators.jl.\n\nusing OrdinaryDiffEqFIRK, OrdinaryDiffEqRosenbrock, OrdinaryDiffEqSDIRK\nusing PositiveIntegrators\n# select problem\nprob = prob_pds_stratreac\nnothing # hide\n\nTo keep the following code as clear as possible, we define a helper function stratreac_plot that we use for plotting.\n\nusing Plots\n\nfunction stratreac_plot(sols, labels = fill(\"\", length(sols)), sol_ref = nothing)\n    if !(sols isa Vector)\n        sols = [sols]\n    end\n    if !(labels isa Vector)\n        labels = [labels]\n    end\n\n    tspan = prob_pds_stratreac.tspan\n    layout = (3, 2)\n    linewidth = 2\n    xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4))\n    tickfontsize = 7\n    xguide = \"t [h]\" #fill(\"t [h]\", 1, 6)\n    xguidefontsize = 8\n    yguide = [\"O¹ᴰ\" \"O\" \"O₃\" \"O₂\" \"NO\" \"NO₂\"]\n    ylims = [(-20, 120) (-1e8, 7e8) (2e11, 6e11) (1.69699e16, 1.69705e16) (-2e6, 1.2e7) (1.084e9,\n                                                                                         1.098e9)]\n    legend = :outertop\n    legend_column = -1\n    widen = true\n\n    if !isnothing(sol_ref)\n        p = plot(ref_sol; layout, linestyle = :dash, label = \"Ref.\", linewidth)\n        for (sol, label) in zip(sols, labels)\n            plot!(p, sol; xguide, xguidefontsize, xticks, tickfontsize, yguide, legend,\n                  legend_column, widen, ylims, linewidth, label, denseplot = false)\n        end\n    else\n        p = plot(sols[1]; layout, xguide, xguidefontsize, xticks, tickfontsize, yguide,\n                 legend, legend_column, widen, ylims, linewidth,\n                 label = labels[1])\n        if length(sols) > 1\n            for (sol, label) in zip(sols[2:end], labels[2:end])\n                plot!(p, sol; layout, xguide, xguidefontsize, xticks, tickfontsize, yguide,\n                      legend, legend_column, widen, label, denseplot = false, linewidth,\n                      ylims)\n            end\n        end\n    end\n    return p\nend\nnothing # hide\n\nFirst, we show approximations of Rosenbrock23() using loose tolerances.\n\n# compute reference solution for plotting\nref_sol = solve(prob, Rodas4P(); abstol = 1e-12, reltol = 1e-11);\n\n# compute solution with low tolerances\nabstol = 1e-3\nreltol = 1e-2\nsol_Ros23 = solve(prob, Rosenbrock23(); abstol, reltol);\n\n# plot solution\nstratreac_plot(sol_Ros23,  \"Ros23\", ref_sol)\n\nAlthough not visible in the plots, the Rosenbrock23 solution contains negative values.\n\nisnonnegative(sol_Ros23)\n\nNevertheless, OrdinaryDiffEq.jl provides the solver option isoutofdomain, which can be used in combination with isnegative to guarantee nonnegative solutions.\n\n# compute solution with isoutofdomain = isnegative\nsol_Ros23 = solve(prob, Rosenbrock23(); abstol, reltol,\n                  isoutofdomain = isnegative); #reject negative solutions\n\n# plot solution\nstratreac_plot(sol_Ros23,  \"Ros23\", ref_sol)\n\nFor this problem, using adaptive MPRK schemes with loose tolerances will generally lead to poor approximations, particularly regarding the O₂ component.\n\nsol_MPRK = solve(prob, MPRK22(1.0); abstol, reltol);\n\n# plot solutions\nstratreac_plot(sol_MPRK, \"MPRK22(1.0)\", ref_sol)\n\nTo improve the solution of the MPRK scheme we can inrecase the method's small_constant. Trial and error has shown that small_constant = 1e-6 is a good value for this problem and the given tolerances.\n\n# compute MPRK solution with modified small_constant\nsol_MPRK = solve(prob, MPRK22(1.0, small_constant = 1e-6); abstol, reltol);\n\n# plot solution\nstratreac_plot(sol_MPRK, \"MPRK22(1.0)\", ref_sol)\n\nThe remaining poor approximation of the O₂ component could be due to the fact that the MPRK methods do not preserve all linear invariants, as is the case with standard methods like Runge-Kutta or Rosenbrock schemes.","category":"section"},{"location":"stratospheric_reaction_benchmark/#Work-Precision-diagrams","page":"Stratospheric reaction problem","title":"Work-Precision diagrams","text":"In the following we show several work-precision diagrams, which compare different methods with respect to computing times and errors. First we focus on adaptive methods, afterwards we also show results obtained with fixed time step sizes.\n\nSince the stratospheric reaction problem is stiff, we need to use a suited implicit scheme to compute its reference solution.\n\n# select solver to compute reference solution\nalg_ref = Rodas4P()\nnothing  # hide\n\nThe error chosen to compare the performances of different solvers is the relative maximum error at the final time t = 84 hours (t = 302400 seconds).\n\n# select relative maximum error at the end of the problem's time span.\ncompute_error = rel_max_error_tend\nnothing # hide","category":"section"},{"location":"stratospheric_reaction_benchmark/#Adaptive-time-stepping","page":"Stratospheric reaction problem","title":"Adaptive time stepping","text":"We use the functions work_precision_adaptive and work_precision_adaptive! to compute the data for the diagrams. Furthermore, the following absolute and relative tolerances are used.\n\nabstols = 1.0 ./ 10.0 .^ (2:1:5)\nreltols = 10.0 .* abstols\nnothing # hide\n\nWe also note that MPRK schemes with stricter tolerances, quickly require more than a million time steps, which makes these schemes inefficient in such situations.\n\nFirst we compare different low-order MPRK schemes. In addition to the default version we also use the schemes with small_constant = 1e-6.\n\n# choose methods to compare\nalgs = [MPRK22(1.0); MPRK22(1.0, small_constant = 1e-6); SSPMPRK22(0.5, 1.0); SSPMPRK22(0.5, 1.0, small_constant = 1e-6);\n        MPRK43I(1.0, 0.5); MPRK43I(1.0, 0.5, small_constant = 1e-6); MPRK43I(0.5, 0.75); MPRK43I(0.5, 0.75, small_constant = 1e-6)\n        MPRK43II(0.5); MPRK43II(0.5, small_constant = 1e-6); MPRK43II(2.0 / 3.0); MPRK43II(2.0 / 3.0, small_constant = 1e-6)]\nlabels = [\"MPRK22(1.0)\"; \"MPRK22(1.0, sc=1e-6)\"; \"SSPMPRK22(0.5,1.0)\"; \"SSPMPRK22(0.5,1.0, sc=1e-6)\";\n          \"MPRK43I(1.0,0.5)\"; \"MPRK43I(1.0,0.5, sc=1e-6)\"; \"MPRK43I(0.5,0.75)\"; \"MPRK43I(0.5,0.75, sc=1e-6)\"; \"MPRK43II(0.5)\"; \"MPRK43II(0.5, sc=1e-6)\"\n          \"MPRK43II(2.0/3.0)\"; \"MPRK43II(2.0/3.0, sc=1e-6)\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref; compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"Stratospheric reaction benchmark\", legend = :bottomleft,\n     color = permutedims([repeat([1],2)..., repeat([2],2)..., repeat([3],4)..., repeat([4],4)...]),\n     xlims = (10^-7, 10^0), xticks = 10.0 .^ (-7:1:0),\n     ylims = (10^-5, 10^1), yticks = 10.0 .^ (-5:1:1), minorticks = 10)\n\nWe see that using small_constant = 1e-6 clearly improves the performance of some methods.  Next, we include the MPDeC methods in the comparison and use MPRK22(1.0, small_constant = 1e-6) and MPRK43I(1.0, 0.5) as a reference. \n\n# choose methods to compare\nalgs = [MPRK22(1.0, small_constant = 1e-6); MPRK43I(1.0, 0.5); \n        MPDeC(2); MPDeC(3); MPDeC(4); MPDeC(5); MPDeC(6); MPDeC(7); MPDeC(8); MPDeC(9); MPDeC(10);\n        MPDeC(2, small_constant = 1e-6); MPDeC(3, small_constant = 1e-6); MPDeC(4, small_constant = 1e-6); MPDeC(5, small_constant = 1e-6); MPDeC(6, small_constant = 1e-6); \n        MPDeC(7, small_constant = 1e-6); MPDeC(8, small_constant = 1e-6); MPDeC(9, small_constant = 1e-6); MPDeC(10, small_constant = 1e-6)]\nlabels = [\"MPRK22(1.0, sc=1e-6)\"; \"MPRK43I(1.0,0.5)\"; \n          \"MPDeC(2)\"; \"MPDeC(3)\"; \"MPDeC(4)\"; \"MPDeC(5)\"; \"MPDeC(6)\"; \"MPDeC(7)\"; \"MPDeC(8)\"; \"MPDeC(9)\"; \"MPDeC(10)\";\n          \"MPDeC(2, sc=1e-6)\"; \"MPDeC(3, sc=1e-6)\"; \"MPDeC(4, sc=1e-6)\"; \"MPDeC(5, sc=1e-6)\"; \"MPDeC(6, sc=1e-6)\"; \"MPDeC(7, sc=1e-6)\"; \"MPDeC(8, sc=1e-6)\"; \"MPDeC(9, sc=1e-6)\"; \"MPDeC(10, sc=1e-6)\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref; compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"Stratospheric reaction benchmark\", legend = :outerright,\n     color = permutedims([1, 2, repeat([3],5)..., repeat([4],4)..., repeat([5],5)..., repeat([6],4)...]),\n     xlims = (10^-6, 10^0), xticks = 10.0 .^ (-6:1:0),\n     ylims = (10^-4, 10^1), yticks = 10.0 .^ (-4:1:1), minorticks = 10)\n\nAll MPDeC behave quite similar and no performance benefit of higher-order MPDeC methods is observable.  For comparisons with other second- and third-order schemes from OrdinaryDiffEq.jl we choose the second-order scheme MPRK22(1.0, small_constant = 1e-6) and the third-order scheme MPRK43I(1.0, 0.5). To guarantee positive solutions of the OrdinaryDiffEq.jl methods, we select the solver option isoutofdomain = isnegative.\n\n# select reference MPRK methods\nalgs1 = [MPRK22(1.0, small_constant = 1e-6); MPRK43I(1.0, 0.5)]\nlabels1 = [\"MPRK22(1.0, sc=1e-6)\"; \"MPRK43I(1.0,0.5)\"]\n\n# select OrdinaryDiffEq methods\nalgs2 = [TRBDF2(); Kvaerno3(); KenCarp3(); Rodas3(); ROS2(); ROS3(); Rosenbrock23()]\nlabels2 = [\"TRBDF2\"; \"Kvearno3\"; \"KenCarp3\"; \"Rodas3\"; \"ROS2\"; \"ROS3\"; \"Rosenbrock23\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref; compute_error)\nwork_precision_adaptive!(wp, prob, algs2, labels2, abstols, reltols, alg_ref; compute_error,\n                        isoutofdomain = isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels2]; title = \"Stratospheric reaction benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 3)..., repeat([5], 4)...]),\n     xlims = (10^-8, 10^0), xticks = 10.0 .^ (-8:1:0),\n     ylims = (2*10^-4, 5*10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)\n\nWe see that MPRK methods are advantageous if low accuracy is acceptable.\n\nIn addition,  we compare MPRK22(1.0, small_constant = 1e-6) and  MPRK43I(1.0, 0.5) to some recommended solvers of higher order from OrdinaryDiffEq.jl. Again, to guarantee positive solutions we select the solver option isoutofdomain = isnegative.\n\n# select OrdinaryDiffEq methods\nalgs3 = [Rodas5P(); Rodas4P(); RadauIIA5()]\nlabels3 = [\"Rodas5P\"; \"Rodas4P\"; \"RadauIIA5\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref; compute_error)\nwork_precision_adaptive!(wp, prob, algs3, labels3, abstols, reltols, alg_ref; compute_error,\n                        isoutofdomain = isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels3]; title = \"Stratospheric reaction benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 3)...]),\n     xlims = (10^-7, 10^0), xticks = 10.0 .^ (-8:1:0),\n     ylims = (2*10^-4, 5*10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)\n\nAgain, it can be seen that MPRK methods are only advantageous if low accuracy is acceptable.","category":"section"},{"location":"stratospheric_reaction_benchmark/#Fixed-time-steps-sizes","page":"Stratospheric reaction problem","title":"Fixed time steps sizes","text":"Here we use fixed time step sizes instead of adaptive time stepping. We use the functions work_precision_fixed and work_precision_fixed! to compute the data for the diagrams. Please note that these functions set error and computing time to Inf, whenever a solution contains negative elements. Consequently, such cases are not visible in the work-precision diagrams.\n\nWithin the work-precision diagrams we use the following time step sizes.\n\n# set time step sizes\ndt0 = 48 * 60 # 48 minutes\ndts = dt0 ./ 2.0 .^ (0:1:10)\nnothing # hide\n\nIn contrast to the adaptive methods, increasing small_constant does not have a positive effect on accuracy, but actually worsens it. To demonstrate this we compare the default version of MPRK22(1.0) to versions with small_constant = 1e-6 and small_constant = 1e-100.\n\n# solve prob with large step size\nsol1 = solve(prob, MPRK22(1.0); dt = dt0, adaptive = false)\n# plot solution\nstratreac_plot(sol1, \"MPRK22(1.0)\", ref_sol)\n\nsol2 = solve(prob, MPRK22(1.0, small_constant = 1e-6); dt = dt0, adaptive = false)\nstratreac_plot(sol2, \"MPRK22(1.0, sc=1e-6)\", ref_sol)\n\nsol3 = solve(prob, MPRK22(1.0, small_constant = 1e-100); dt = dt0, adaptive = false)\nstratreac_plot(sol3, \"MPRK22(1.0, sc=1e-100)\", ref_sol)\n\nBased on the above comparison, we will only consider schemes in which small_constant is set to the default value in the following.\n\n# select schemes\nalgs = [MPRK22(1.0); SSPMPRK22(0.5, 1.0); MPRK43I(1.0, 0.5); MPRK43I(0.5, 0.75); MPRK43II(0.5); MPRK43II(2.0 / 3.0);\n        SSPMPRK43();\n        MPDeC(2); MPDeC(3); MPDeC(4); MPDeC(5); MPDeC(6); MPDeC(7); MPDeC(8); MPDeC(9); MPDeC(10)]\nlabels = [\"MPRK22(1.0)\"; \"SSPMPRK22(0.5,1.0)\"; \"MPRK43I(1.0,0.5)\"; \"MPRK43I(0.5,0.75)\";  \"MPRK43II(0.5)\"; \"MPRK43II(2.0/3.0)\";\n          \"SSPMPRK43()\";\n          \"MPDeC(2)\"; \"MPDeC(3)\"; \"MPDeC(4)\"; \"MPDeC(5)\"; \"MPDeC(6)\"; \"MPDeC(7)\"; \"MPDeC(8)\"; \"MPDeC(9)\"; \"MPDeC(10)\"]\n\n# compute work-precision data\nwp = work_precision_fixed(prob, algs, labels, dts, alg_ref; compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"Stratospheric reaction benchmark\", legend = :outerright,\n     color = permutedims([1, 2, repeat([3],2)..., repeat([4],2)..., 5, repeat([6],5)..., repeat([7],4)...]),\n     xlims = (10^-8, 10^2), xticks = 10.0 .^ (-8:1:2),\n     ylims = (10^-5, 10^1), yticks = 10.0 .^ (-5:1:1), minorticks = 10)\n\nApart from SSPMPRK22(0.5, 1.0) all schemes perform quite similar. We choose MPRK22(1.0), MPRK43II(0.5) and MPDeC(10) for comparisons with other schemes.\n\nFor the chosen time step sizes none of the above used standard schemes provides nonnegative solutions.\n\n# select reference MPRK methods\nalgs = [MPRK22(1.0); MPRK43II(0.5); MPDeC(10); TRBDF2(); Kvaerno3(); KenCarp3(); Rodas3(); ROS2(); ROS3(); Rosenbrock23();\n         Rodas5P(); Rodas4P()]\nlabels = [\"MPRK22(1.0)\"; \"MPRK43II(0.5)\"; \"MPDeC(10)\"; \"TRBDF2\"; \"Kvearno3\"; \"KenCarp3\"; \"Rodas3\"; \"ROS2\"; \"ROS3\"; \"Rosenbrock23\";\n          \"Rodas5P\"; \"Rodas4P\"]\n\n# compute work-precision data\nwp = work_precision_fixed(prob, algs, labels, dts, alg_ref; compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"Stratospheric reaction benchmark\", legend = :bottomleft,\n     color = permutedims([1, 3, 7, repeat([4], 3)..., repeat([5], 4)..., repeat([6], 3)...]),\n     xlims = (10^-8, 10^1), xticks = 10.0 .^ (-8:2:1),\n     ylims = (10^-5, 10^1), yticks = 10.0 .^ (-5:1:1), minorticks = 10)","category":"section"},{"location":"stratospheric_reaction_benchmark/#Package-versions","page":"Stratospheric reaction problem","title":"Package versions","text":"These results were obtained using the following versions.\n\nusing InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"LinearSolve\",\n            \"OrdinaryDiffEqFIRK\", \"OrdinaryDiffEqRosenbrock\",\n            \"OrdinaryDiffEqSDIRK\"],\n           mode = PKGMODE_MANIFEST)\nnothing # hide","category":"section"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"ContributingPositiveIntegrators.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as pull requests) any time. For planned larger contributions, it is often beneficial to get in contact first, for example via issues.PositiveIntegrators.jl and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.Developer Certificate of Origin (Version 1.1)The following text was taken from https://developercertificate.org:Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"section"},{"location":"npzd_model/#tutorial-npzd","page":"NPZD model","title":"Tutorial: Solution of an NPZD model","text":"This tutorial is about the efficient solution of production-destruction systems (PDS) with a small number of differential equations. We will compare the use of standard arrays and static arrays from StaticArrays.jl and assess their efficiency.","category":"section"},{"location":"npzd_model/#Definition-of-the-production-destruction-system","page":"NPZD model","title":"Definition of the production-destruction system","text":"The NPZD model we want to solve was described by Burchard, Deleersnijder and Meister in Application of modified Patankar schemes to stiff biogeochemical models for the water column. The model reads\n\nbeginaligned\nN = 001P + 001Z + 0003D - fracNP001 + N\nP = fracNP001 + N- 001P - 05( 1 - e^-121P^2)Z - 005P\nZ = 05(1 - e^-121P^2)Z - 001Z - 002Z\nD = 005P + 002Z - 0003D\nendaligned\n\nand we consider the initial conditions N=8, P=2, Z=1 and D=4. The time domain of interest is tin010.\n\nThe model can be represented as a conservative PDS with production terms\n\nbeginaligned\np_12 = 001 P  p_13 = 001 Z  p_14 = 0003 D\np_21 = fracNP001 + N  p_32 = 05  (10 - e^-121  P^2)  Z p_42 = 005  P\np_43 = 002  Z\nendaligned\n\nwhereby production terms not listed have the value zero. Since the PDS is conservative, we have d_ij=p_ji and the system is fully determined by the production matrix (p_ij)_ij=1^4.","category":"section"},{"location":"npzd_model/#Solution-of-the-production-destruction-system","page":"NPZD model","title":"Solution of the production-destruction system","text":"Now we are ready to define a ConservativePDSProblem and to solve this problem with a method of PositiveIntegrators.jl or OrdinaryDiffEq.jl.\n\nAs mentioned above, we will try different approaches to solve this PDS and compare their efficiency. These are\n\nan out-of-place implementation with standard (dynamic) matrices and vectors,\nan in-place implementation with standard (dynamic) matrices and vectors,\nan out-of-place implementation with static matrices and vectors from StaticArrays.jl.","category":"section"},{"location":"npzd_model/#Standard-out-of-place-implementation","page":"NPZD model","title":"Standard out-of-place implementation","text":"Here we create a function to compute the production matrix with return type Matrix{Float64}.\n\nusing PositiveIntegrators # load ConservativePDSProblem\n\nfunction prod(u, p, t)\n    N, P, Z, D = u\n\n    p12 = 0.01 * P\n    p13 = 0.01 * Z\n    p14 = 0.003 * D\n    p21 = N / (0.01 + N) * P\n    p32 = 0.5 * (1.0 - exp(-1.21 * P^2)) * Z\n    p42 = 0.05 * P\n    p43 = 0.02 * Z\n\n    return [0.0 p12 p13 p14;\n            p21 0.0 0.0 0.0;\n            0.0 p32 0.0 0.0;\n            0.0 p42 p43 0.0]\nend\nnothing #hide\n\nThe solution of the NPZD model can now be computed as follows.\n\nu0 = [8.0, 2.0, 1.0, 4.0] # initial values\ntspan = (0.0, 10.0) # time domain\nprob_oop = ConservativePDSProblem(prod, u0, tspan) # create the PDS\n\nsol_oop = solve(prob_oop, MPRK43I(1.0, 0.5))\n\nnothing #hide\n\nPlotting the solution shows that the components N and P are in danger of becoming negative.\n\nusing Plots\n\nplot(sol_oop; label = [\"N\" \"P\" \"Z\" \"D\"], xguide = \"t\")\n\nPositiveIntegrators.jl provides the function isnonnegative (and also isnegative) to check if the solution is actually nonnegative, as expected from an MPRK scheme.\n\nisnonnegative(sol_oop)","category":"section"},{"location":"npzd_model/#Standard-in-place-implementation","page":"NPZD model","title":"Standard in-place implementation","text":"Next we create an in-place function for the production matrix.\n\n\nfunction prod!(PMat, u, p, t)\n    N, P, Z, D = u\n\n    p12 = 0.01 * P\n    p13 = 0.01 * Z\n    p14 = 0.003 * D\n    p21 = N / (0.01 + N) * P\n    p32 = 0.5 * (1.0 - exp(-1.21 * P^2)) * Z\n    p42 = 0.05 * P\n    p43 = 0.02 * Z\n\n    fill!(PMat, zero(eltype(PMat)))\n\n    PMat[1, 2] = p12\n    PMat[1, 3] = p13\n    PMat[1, 4] = p14\n    PMat[2, 1] = p21\n    PMat[3, 2] = p32\n    PMat[4, 2] = p42\n    PMat[4, 3] = p43\n\n    return nothing\nend\nnothing #hide\n\nThe solution of the in-place implementation of the NPZD model can now be computed as follows.\n\n\nprob_ip = ConservativePDSProblem(prod!, u0, tspan)\nsol_ip = solve(prob_ip, MPRK43I(1.0, 0.5))\nnothing #hide\n\n\nplot(sol_ip; label = [\"N\" \"P\" \"Z\" \"D\"], xguide = \"t\")\n\nWe also check that the in-place and out-of-place solutions are equivalent.\n\nsol_oop.t ≈ sol_ip.t && sol_oop.u ≈ sol_ip.u","category":"section"},{"location":"npzd_model/#Using-static-arrays","page":"NPZD model","title":"Using static arrays","text":"For PDS with a small number of differential equations like the NPZD model the use of static arrays will be more efficient. To create a function which computes the production matrix and returns a static matrix, we only need to add the @SMatrix macro.\n\nusing StaticArrays\n\nfunction prod_static(u, p, t)\n    N, P, Z, D = u\n\n    p12 = 0.01 * P\n    p13 = 0.01 * Z\n    p14 = 0.003 * D\n    p21 = N / (0.01 + N) * P\n    p32 = 0.5 * (1.0 - exp(-1.21 * P^2)) * Z\n    p42 = 0.05 * P\n    p43 = 0.02 * Z\n\n    return @SMatrix [0.0 p12 p13 p14;\n                     p21 0.0 0.0 0.0;\n                     0.0 p32 0.0 0.0;\n                     0.0 p42 p43 0.0]\nend\nnothing #hide\n\nIn addition we also want to use a static vector to hold the initial conditions.\n\nu0_static = @SVector [8.0, 2.0, 1.0, 4.0] # initial values\nprob_static = ConservativePDSProblem(prod_static, u0_static, tspan) # create the PDS\n\nsol_static = solve(prob_static, MPRK43I(1.0, 0.5))\n\nnothing #hide\n\nusing Plots\n\nplot(sol_static; label = [\"N\" \"P\" \"Z\" \"D\"], xguide = \"t\")\n\nThis solution is also nonnegative.\n\nisnonnegative(sol_static)\n\nThe above implementation of the NPZD model using StaticArrays can also be found in the Example Problems as prob_pds_npzd.","category":"section"},{"location":"npzd_model/#Performance-comparison","page":"NPZD model","title":"Performance comparison","text":"Finally, we use BenchmarkTools.jl to show the benefit of using static arrays.\n\nusing BenchmarkTools\n@benchmark solve(prob_oop, MPRK43I(1.0, 0.5))\n\nusing BenchmarkTools\n@benchmark solve(prob_ip, MPRK43I(1.0, 0.5))\n\n@benchmark solve(prob_static, MPRK43I(1.0, 0.5))","category":"section"},{"location":"npzd_model/#Package-versions","page":"NPZD model","title":"Package versions","text":"These results were obtained using the following versions.\n\nusing InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"LinearSolve\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"section"},{"location":"npzd_model_benchmark/#benchmark-npzd","page":"NPZD model","title":"Benchmark: Solution of an NPZD model","text":"We use the NPZD model prob_pds_npzd to assess the efficiency of different solvers from OrdinaryDiffEq.jl and PositiveIntegrators.jl.\n\nusing OrdinaryDiffEqLowOrderRK, OrdinaryDiffEqSDIRK, OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqTsit5, OrdinaryDiffEqVerner\nusing PositiveIntegrators\n\n# select NPZD problem\nprob = prob_pds_npzd\nnothing # hide\n\nTo keep the following code as clear as possible, we define a helper function npzd_plot that we use for plotting.\n\nusing Plots\n\nfunction npzd_plot(sol, sol_ref = nothing, title = \"\")\n     colors = palette(:default)[1:4]'\n     if !isnothing(sol_ref)\n          p = plot(sol_ref, linestyle = :dash, label = \"\", color = colors,\n                   linewidth = 2)\n          plot!(p, sol; denseplot = false, markers = :circle, ylims = (-1.0, 10.0),\n                color = colors, title, label = [\"N\" \"P\" \"Z\" \"D\"], legend = :right,\n                linewidth = 2);\n     else\n          p = plot(sol; denseplot = false, markers = :circle, ylims = (-1.0, 10.0),\n                   color = colors, title, label = [\"N\" \"P\" \"Z\" \"D\"], legend = :right,\n                   linewidths = 2);\n     end\n     return p\nend\nnothing  # hide\n\nStandard methods have difficulties to solve the NPZD problem accurately for loose tolerances or large time step sizes. This is because the first variable, N, has only a tiny margin for negative values. In most cases, negative values of N will directly lead to a further decrease in N, resulting in completely inaccurate solutions.\n\n# compute reference solution for plotting\nref_sol = solve(prob, Vern7(); abstol = 1e-14, reltol = 1e-13);\n\n# compute solutions with loose tolerances\nabstol = 1e-2\nreltol = 1e-1\nsol_Ros23 = solve(prob, Rosenbrock23(); abstol, reltol);\nsol_MPRK = solve(prob, MPRK22(1.0); abstol, reltol);\n\n# plot solutions\np1 = npzd_plot(sol_Ros23, ref_sol, \"Rosenbrock23\"); # helper function defined above\np2 = npzd_plot(sol_MPRK, ref_sol, \"MPRK22(1.0)\");\nplot(p1, p2)\n\nNevertheless, OrdinaryDiffEq.jl provides the solver option isoutofdomain, which can be used in combination with isnegative to guarantee nonnegative solutions.\n\nsol_Ros23 = solve(prob, Rosenbrock23(); abstol, reltol,\n                  isoutofdomain = isnegative); #reject negative solutions\n\nnpzd_plot(sol_Ros23, ref_sol) #auxiliary function defined above","category":"section"},{"location":"npzd_model_benchmark/#Work-Precision-diagrams","page":"NPZD model","title":"Work-Precision diagrams","text":"In the following sections, we present several work-precision diagrams that compare various methods in terms of computing time and error. First, we focus on adaptive methods; afterward, we also display resultsixed time step sizes. obtained with f\n\nSince the NPZD problem is not stiff, we can use an explicit high-order scheme to compute a reference solution.\n\n# select solver to compute reference solution\nalg_ref = Vern7()\nnothing  # hide","category":"section"},{"location":"npzd_model_benchmark/#Adaptive-schemes","page":"NPZD model","title":"Adaptive schemes","text":"We use the functions work_precision_adaptive and work_precision_adaptive! to compute the data for the diagrams. Furthermore, the following absolute and relative tolerances are used.\n\n# set absolute and relative tolerances\nabstols = 1.0 ./ 10.0 .^ (2:1:8)\nreltols = abstols .* 10.0\nnothing  # hide","category":"section"},{"location":"npzd_model_benchmark/#Relative-maximum-error-at-the-final-time","page":"NPZD model","title":"Relative maximum error at the final time","text":"In this section the chosen error is the relative maximum error at the final time t = 100.\n\n# select relative maximum error at the end of the problem's time span.\ncompute_error = rel_max_error_tend\nnothing # hide\n\nWe start with a comparison of different adaptive MPRK schemes.\n\n# choose methods to compare\nalgs = [MPRK22(0.5); MPRK22(2.0 / 3.0); MPRK22(1.0); SSPMPRK22(0.5, 1.0);\n        MPRK43I(1.0, 0.5); MPRK43I(0.5, 0.75); MPRK43II(0.5); MPRK43II(2.0 / 3.0);\n        MPDeC(2); MPDeC(3); MPDeC(4); MPDeC(5); MPDeC(6); MPDeC(7); MPDeC(8); MPDeC(9); MPDeC(10)]\nlabels = [\"MPRK22(0.5)\"; \"MPPRK22(2/3)\"; \"MPRK22(1.0)\"; \"SSPMPRK22(0.5,1.0)\";\n          \"MPRK43I(1.0, 0.5)\"; \"MPRK43I(0.5, 0.75)\"; \"MPRK43II(0.5)\"; \"MPRK43II(2.0/3.0)\";\n          \"MPDeC(2)\"; \"MPDeC(3)\"; \"MPDeC(4)\"; \"MPDeC(5)\"; \"MPDeC(6)\"; \"MPDeC(7)\"; \"MPDeC(8)\"; \"MPDeC(9)\"; \"MPDeC(10)\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref; compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"NPZD benchmark\", legend = :outerright,\n     color = permutedims([repeat([1], 3)..., 2, repeat([3], 2)..., repeat([4], 2)..., repeat([5], 5)..., repeat([6], 4)...]),\n     xlims = (10^-8, 2*10^-1), xticks = 10.0 .^ (-8:1:0),\n     ylims = (10^-5, 10^-1), yticks = 10.0 .^ (-5:1:-1), minorticks = 10)\n\nAll methods behave very similarly. In particular, there is no superior performance of the high-order MPDeC methods. For comparisons with other schemes we choose MPRK22(1.0) and MPRK43I(1.0, 0.5).\n\nsol_MPRK22 = solve(prob, MPRK22(1.0); abstol, reltol)\nsol_MPRK43 = solve(prob, MPRK43I(1.0, 0.5); abstol, reltol)\n\np1 = npzd_plot(sol_MPRK22, ref_sol, \"MPRK22(1.0)\");\np2 = npzd_plot(sol_MPRK43, ref_sol, \"MPRK43I(1.0, 0.5)\");\nplot(p1, p2)\n\nNext we compare MPRK22(1.0) and MPRK43I(1.0, 0.5) with explicit and implicit methods of second and third order from OrdinaryDiffEq.jl. To guarantee nonnegative solutions, we select the solver option isoutofdomain = isnegative.\n\n# select MPRK methods for reference\nalgs1 = [MPRK22(1.0); MPRK43I(1.0, 0.5)]\nlabels1 = [\"MPRK22(1.0)\"; \"MPRK43I(1.0,0.5)\"]\n\n# select methods from OrdinaryDiffEq\nalgs2 = [Midpoint(); Heun(); Ralston(); TRBDF2(); SDIRK2(); Kvaerno3(); KenCarp3(); Rodas3();\n         ROS2(); ROS3(); Rosenbrock23()]\nlabels2 = [\"Midpoint\"; \"Heun\"; \"Ralston\"; \"TRBDF2\"; \"SDIRK2\"; \"Kvearno3\"; \"KenCarp3\"; \"Rodas3\";\n          \"ROS2\"; \"ROS3\"; \"Rosenbrock23\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               compute_error)\n# add work-precision data with isoutofdomain=isnegative\nwork_precision_adaptive!(wp, prob, algs2, labels2, abstols, reltols, alg_ref;\n                               compute_error, isoutofdomain=isnegative)\n\nplot(wp, [labels1; labels2]; title = \"NPZD benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 3)..., repeat([5], 4)..., repeat([6], 4)...]),\n     xlims = (5*10^-8, 2*10^-1), xticks = 10.0 .^ (-8:1:0),\n     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)\n\nWe see that for the NPZD problem the use of adaptive MPRK schemes is only beneficial when using the loosest tolerances.\n\nNow we compare MPRK22(1.0) and MPRK43I(1.0, 0.5) to recommended solvers from OrdinaryDiffEq.jl. Again, to guarantee positive solutions we select the solver option isoutofdomain = isnegative.\n\nalgs3 = [Tsit5(); BS3(); Vern6(); Vern7(); Vern8(); TRBDF2(); Rosenbrock23();\n         Rodas5P(); Rodas4P()]\nlabels3 = [\"Tsit5\"; \"BS3\"; \"Vern6\"; \"Vern7\"; \"Vern8\"; \"TRBDF2\"; \"Rosenbrock23\";\n          \"Rodas5P\"; \"Rodas4P\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               compute_error)\n# add work-precision data with isoutofdomain = isnegative\nwork_precision_adaptive!(wp, prob, algs3, labels3, abstols, reltols, alg_ref;\n                               compute_error, isoutofdomain = isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels3]; title = \"NPZD benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 5)...,5, repeat([6], 1)...,repeat([7],2)...]),\n     xlims = (10^-11, 10^1), xticks = 10.0 .^ (-11:1:1),\n     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)\n\nWe see that it is advisable to use a high-order explicit method like Vern7() or Rosenbrock methods like Rodas4P() with isoutofdomain = isnegative to obtain nonnegative solutions of such a non-stiff problem.","category":"section"},{"location":"npzd_model_benchmark/#Relative-maximum-error-over-all-time-steps","page":"NPZD model","title":"Relative maximum error over all time steps","text":"In this section we do not compare the relative maximum errors at the final time t = 100, but the relative maximum errors over all time steps.\n\n# select relative maximum error over all time steps\ncompute_error = rel_max_error_overall\nnothing  # hide\n\nThe results are very similar to those from above. We therefore only show the work-precision diagrams without further comments. The main difference are significantly increased errors which mainly occur around time t = 20 where there is a sharp kink in the solution.\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref;\n                               compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"NPZD benchmark\", legend = :outerright,\n          color = permutedims([repeat([1], 3)..., 2, repeat([3], 2)..., repeat([4], 2)..., repeat([5], 5)..., repeat([6], 4)...]),\n          xlims = (10^-5, 10^4), xticks = 10.0 .^ (-5:1:4),\n          ylims = (10^-5, 10^-1), yticks = 10.0 .^ (-5:1:0), minorticks = 10)\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               compute_error)\n# add work-precision data with isoutofdomain = isnegative\nwork_precision_adaptive!(wp, prob, algs2, labels2, abstols, reltols, alg_ref;\n                               compute_error, isoutofdomain=isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels2]; title = \"NPZD benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 3)..., repeat([5], 4)..., repeat([6], 4)...]),\n     xlims = (10^-5, 10^4), xticks = 10.0 .^ (-5:1:4),\n     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-6:1:0), minorticks = 10)\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               compute_error)\n# add work-precision data with isoutofdomain = isnegative\nwork_precision_adaptive!(wp, prob, algs3, labels3, abstols, reltols, alg_ref;\n                               compute_error, isoutofdomain=isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels3]; title = \"NPZD benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 5)...,5, repeat([6], 1)...,repeat([7],2)...]),\n     xlims = (10^-7, 10^5), xticks = 10.0 .^ (-7:1:5),\n     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-6:1:0), minorticks = 10)","category":"section"},{"location":"npzd_model_benchmark/#Fixed-time-step-sizes","page":"NPZD model","title":"Fixed time step sizes","text":"Here we use fixed time step sizes instead of adaptive time stepping. Similar to the adaptive situation above, standard schemes are likely to compute negative solutions for the NPZD problem.\n\nsol_Ros23 = solve(prob, Rosenbrock23(), dt = 1.0, adaptive = false);\nsol_MPRK = solve(prob, MPRK22(1.0), dt = 1.0, adaptive = false);\n\np1 = npzd_plot(sol_Ros23, ref_sol, \"Rosenbrock23\");\np2 = npzd_plot(sol_MPRK, ref_sol, \"MPRK22(1.0)\");\nplot(p1, p2)\n\nWe use the functions work_precision_fixed and work_precision_fixed! to compute the data for the diagrams. Please note that these functions set error and computing time to Inf, whenever a solution contains negative elements. Consequently, such cases are not visible in the work-precision diagrams.\n\nWithin the work-precision diagrams we use the following time step sizes.\n\n# set time step sizes\ndts = 1.0 ./ 2.0 .^ (0:1:12)\nnothing # hide","category":"section"},{"location":"npzd_model_benchmark/#Relative-maximum-error-at-the-end-of-the-problem's-time-span","page":"NPZD model","title":"Relative maximum error at the end of the problem's time span","text":"Again, we start with the relative maximum error at the final time t = 100.\n\n# select relative maximum error at the end of the problem's time span.\ncompute_error = rel_max_error_tend\nnothing  # hide\n\nFirst, we compare different MPRK methods. For fixed time step sizes we can also consider MPE() and SSPMPRK43().\n\n# choose MPRK methods to compare\nalgs = [MPE(); algs; SSPMPRK43()]\nlabels = [\"MPE()\"; labels; \"SSPMPRK43\"]\n\n# compute work-precision data\nwp = work_precision_fixed(prob, algs, labels, dts, alg_ref;\n                          compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"NPZD benchmark\", legend = :outerright,\n     color = permutedims([5,repeat([1], 3)..., 2, repeat([3], 2)..., repeat([4], 2)..., repeat([5], 5)..., repeat([6], 4)..., 7]),\n     xlims = (10^-13, 1*10^0), xticks = 10.0 .^ (-13:1:0),\n     ylims = (1*10^-6, 10^1), yticks = 10.0 .^ (-6:1:1), minorticks = 10)\n\nApart from MPE() the schemes behave very similar and there is no superior performance of the higher-order schemes observable. We choose MPRK22(1.0) and MPRK43I(1.0, 0.5) for comparisons with other schemes from OrdinaryDiffEq.jl. First, we compare these methods with other second- and third-order schemes.\n\n# compute work-precision data\nwp = work_precision_fixed(prob, [algs1; algs2], [labels1; labels2], dts, alg_ref;\n                               compute_error)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels2]; title = \"NPZD benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 3)..., repeat([5],4)...,repeat([6],4)...]),\n     xlims = (10^-13, 10^2), xticks = 10.0 .^ (-12:2:6),\n     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)\n\nWe see that the MPRK schemes are to be preferred for the rather large step sizes Delta t inlbrace 10 05 025 0125rbrace, for which the other schemes cannot provide nonnegative solutions.\n\n# solution computed with MPRK43I(1.0, 0.5) and dt = 0.125\nsol_MPRK = solve(prob, MPRK43I(1.0, 0.5); dt = dts[4], adaptive = false);\n\n# plot solution\nnpzd_plot(sol_MPRK, ref_sol)\n\nFinally, we show a comparison of MPRK22(1.0), MPRK43I(1.0, 0.5) and recommended solvers from OrdinaryDiffEq.jl.\n\n# compute work-precision data\nwp = work_precision_fixed(prob, [algs1; algs3], [labels1; labels3], dts, alg_ref;\n                               compute_error)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels3]; title = \"NPZD benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 3)..., repeat([5],4)...,repeat([6],4)...]),\n     xlims = (10^-14, 10^0), xticks = 10.0 .^ (-14:2:10),\n     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"section"},{"location":"npzd_model_benchmark/#Relative-maximum-error-over-all-time-steps-2","page":"NPZD model","title":"Relative maximum error over all time steps","text":"As for the adaptive schemes, we also show work-precisions diagrams where the error is the relative maximum error over all time steps.\n\n# select relative maximum error over all time steps\ncompute_error = rel_max_error_overall\nnothing  # hide\n\n\n# compute work-precision\nwp = work_precision_fixed(prob, algs, labels, dts, alg_ref;\n                               compute_error)\n\n#plot work-precision diagram\nplot(wp, labels; title = \"NPZD benchmark\", legend = :outerright,\n     color = permutedims([5,repeat([1], 3)..., 2, repeat([3], 2)..., repeat([4], 2)..., repeat([5], 5)..., repeat([6], 4)..., 7]),\n     xlims = (10^-9, 10^5), xticks = 10.0 .^ (-9:1:5),\n     ylims = (10^-6, 10^1), yticks = 10.0 .^ (-6:1:1), minorticks = 10)\n\nwp = work_precision_fixed(prob, algs1, labels1, dts, alg_ref;\n                               compute_error)\nwork_precision_fixed!(wp, prob, algs2, labels2, dts, alg_ref;\n                     compute_error)\n\nplot(wp, [labels1; labels2]; title = \"NPZD benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 3)..., repeat([5], 4)..., repeat([6], 4)...]),\n     xlims = (10^-4, 10^6), xticks = 10.0 .^ (-12:1:6),\n     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)\n\nwp = work_precision_fixed(prob, algs1, labels1, dts, alg_ref;\n                               compute_error)\nwork_precision_fixed!(wp, prob, algs3, labels3, dts, alg_ref;\n                     compute_error)\n\nplot(wp, [labels1; labels3]; title = \"NPZD benchmark\", legend = :bottomleft,\n     color = permutedims([1, 3, repeat([4], 5)..., 5, repeat([7], 3)...]),\n     xlims = (10^-12, 10^6), xticks = 10.0 .^ (-12:2:6),\n     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"section"},{"location":"npzd_model_benchmark/#Package-versions","page":"NPZD model","title":"Package versions","text":"These results were obtained using the following versions.\n\nusing InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"LinearSolve\",\n            \"OrdinaryDiffEqLowOrderRK\", \"OrdinaryDiffEqSDIRK\",\n            \"OrdinaryDiffEqRosenbrock\", \"OrdinaryDiffEqTsit5\",\n            \"OrdinaryDiffEqVerner\"],\n           mode = PKGMODE_MANIFEST)\nnothing # hide","category":"section"},{"location":"robertson_benchmark/#benchmark-robertson","page":"Robertson problem","title":"Benchmark: Solution of the Robertson problem","text":"Here we use the stiff Robertson problem prob_pds_robertson to assess the efficiency of different solvers from OrdinaryDiffEq.jl and PositiveIntegrators.jl.\n\nusing OrdinaryDiffEqFIRK, OrdinaryDiffEqRosenbrock, OrdinaryDiffEqSDIRK\nusing PositiveIntegrators\n\n# select Robertson problem\nprob = prob_pds_robertson\nnothing # hide\n\nTo keep the following code as clear as possible, we define a helper function robertson_plot that we use for plotting.\n\nusing Plots\n\nfunction robertson_plot(sol, sol_ref = nothing, title = \"\")\n    colors = palette(:default)[1:3]'\n    if !isnothing(sol_ref)\n        p = plot(sol_ref, tspan = (1e-6, 1e11), xaxis = :log,\n                 idxs = [(0, 1), ((x, y) -> (x, 1e4 .* y), 0, 2), (0, 3)],\n                 linestyle = :dash, label = \"\", color = colors, linewidth = 2)\n        plot!(p, sol; tspan = (1e-6, 1e11), xaxis = :log, denseplot = false,\n              markers = :circle, ylims = (-0.2, 1.2),\n              idxs = [(0, 1), ((x, y) -> (x, 1e4 .* y), 0, 2), (0, 3)],\n              title, xticks = 10.0 .^ (-6:4:10), color = colors,\n              linewidht = 2, legend = :right, label = [\"u₁\" \"10⁴ u₂\" \"u₃\"])\n    else\n        p = plot(sol; tspan = (1e-6, 1e11), xaxis = :log, denseplot = false,\n                 markers = :circle, ylims = (-0.2, 1.2),\n                 idxs = [(0, 1), ((x, y) -> (x, 1e4 .* y), 0, 2), (0, 3)],\n                 title, xticks = 10.0 .^ (-6:4:10), color = colors,\n                 linewidht = 2, legend = :right, label = [\"u₁\" \"10⁴ u₂\" \"u₃\"])\n    end\n    return p\nend\nnothing # hide\n\nFor this stiff problem the computation of negative approximations may lead to inaccurate solutions. This typically occurs when adaptive time stepping uses loose tolerances.\n\n# compute reference solution for plotting\nref_sol = solve(prob, Rodas4P(); abstol = 1e-14, reltol = 1e-13);\n\n# compute solutions with loose tolerances\nabstol = 1e-2\nreltol = 1e-1\nsol_Ros23 = solve(prob, Rosenbrock23(); abstol, reltol);\nsol_MPRK = solve(prob, MPRK22(1.0); abstol, reltol);\n\n# plot solutions\np1 = robertson_plot(sol_Ros23, ref_sol, \"Rosenbrock23\");\np2 = robertson_plot(sol_MPRK, ref_sol, \"MPRK22(1.0)\");\nplot(p1, p2)\n\nNevertheless, OrdinaryDiffEq.jl provides the solver option isoutofdomain, which can be used in combination with isnegative to guarantee nonnegative solutions.\n\nsol_Ros23 = solve(prob, Rosenbrock23(); abstol, reltol,\n                  isoutofdomain = isnegative) #reject negative solutions\n\nrobertson_plot(sol_Ros23, ref_sol, \"Rosenbrock23\")","category":"section"},{"location":"robertson_benchmark/#Work-Precision-diagrams","page":"Robertson problem","title":"Work-Precision diagrams","text":"In the following we show several work-precision diagrams, which compare different methods with respect to computing time and the respective error. We focus solely on adaptive methods, since the time interval (0 10^11) is too large to generate accurate solutions with fixed step sizes.\n\nSince the Robertson problem is stiff, we need to use a suited implicit scheme to compute a reference solution, see the solver guide. Note that we cannot use the recommended method radau(), since prob_pds_robertson uses StaticArrays.jl instead of standard Arrays.\n\n# select solver to compute reference solution\nalg_ref = Rodas4P()\nnothing # hide\n\nWe use the functions work_precision_adaptive and work_precision_adaptive! to compute the data for the diagrams. Furthermore, the following absolute and relative tolerances are used.\n\n# set absolute and relative tolerances\nabstols = 1.0 ./ 10.0 .^ (2:1:10)\nreltols = abstols .* 10.0\nnothing # hide","category":"section"},{"location":"robertson_benchmark/#Relative-maximum-error-at-the-final-time","page":"Robertson problem","title":"Relative maximum error at the final time","text":"In this section the chosen error is the relative maximum error at the final time t = 10^11.\n\n# select relative maximum error at the end of the problem's time span.\ncompute_error = rel_max_error_tend\nnothing # hide\n\nWe start with a comparison of different adaptive MPRK schemes.\n\n# choose methods to compare\nalgs = [MPRK22(0.5); MPRK22(2.0 / 3.0); MPRK22(1.0); MPRK43I(1.0, 0.5); MPRK43I(0.5, 0.75);\n        MPRK43II(0.5); MPRK43II(2.0 / 3.0);\n        MPDeC(2); MPDeC(3); MPDeC(4); MPDeC(5); MPDeC(6); MPDeC(7); MPDeC(8); MPDeC(9); MPDeC(10)]\nlabels = [\"MPRK22(0.5)\"; \"MPRK22(2/3)\"; \"MPRK22(1.0)\"; \"MPRK43I(1.0,0.5)\"; \"MPRK43I(0.5,0.75)\";\n         \"MPRK43II(0.5)\"; \"MPRK43II(2.0/3.0)\";\n         \"MPDeC(2)\"; \"MPDeC(3)\"; \"MPDeC(4)\"; \"MPDeC(5)\"; \"MPDeC(6)\"; \"MPDeC(7)\"; \"MPDeC(8)\"; \"MPDeC(9)\"; \"MPDeC(10)\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref;\n                            adaptive_ref = true, compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"Robertson benchmark\", legend = :outerright,\n     color = permutedims([repeat([1], 3)..., repeat([3], 2)..., repeat([4], 2)..., repeat([5], 9)...]),\n     xlims = (10^-10, 10^0), xticks = 10.0 .^ (-10:1:0),\n     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)\n\nWe see that the second- and third-order schemes perform very similar, except for MPRK22(0.5). This superior performance of MPRK22(0.5) cannot be seen in other benchmarks; it is, therefore, an exception here. We also see a benefit in using higher-order MPDeC methods.\n\nThe scheme SSPMPRK22(0.5, 1.0) has not been considered above, since it generates oscillatory solutions that lead to large errors.\n\nsol1 = solve(prob, SSPMPRK22(0.5, 1.0), abstol=1e-5, reltol = 1e-4);\n\n# plot solutions\nrobertson_plot(sol1, ref_sol, \"SSPMPRK22(0.5, 1.0)\")\n\nFor comparisons with schemes from OrdinaryDiffEq.jl, we choose the second-order schemes MPRK22(0.5) and MPRK22(1.0), the third-order scheme MPRK43I(0.5, 0.75) and the 10th order scheme MPDeC(10).\n\nsol_MPRK22_½ = solve(prob, MPRK22(0.5); abstol, reltol)\nsol_MPRK22_1 = solve(prob, MPRK22(1.0); abstol, reltol)\nsol_MPRK43 = solve(prob, MPRK43I(0.5, 0.75); abstol, reltol)\nsol_MPDeC10 = solve(prob, MPDeC(10); abstol, reltol)\n\np1 = robertson_plot(sol_MPRK22_½, ref_sol, \"MPRK22(0.5)\");\np2 = robertson_plot(sol_MPRK22_1, ref_sol, \"MPRK22(1.0)\");\np3 = robertson_plot(sol_MPRK43, ref_sol, \"MPRK43I(0.5, 0.75)\");\np4 = robertson_plot(sol_MPDeC10, ref_sol, \"MPDeC(10)\");\nplot(p1, p2, p3, p4)\n\nNext, we compare these four schemes with a selection of second- and third-order stiff solvers from OrdinaryDiffEq.jl. To guarantee nonnegative solutions, we use the solver option isoutofdomain = isnegative.\n\n# select reference MPRK methods\nalgs1 = [MPRK22(0.5); MPRK22(1.0); MPRK43I(0.5, 0.75); MPDeC(10)]\nlabels1 = [\"MPRK22(0.5)\"; \"MPRK22(1.0)\"; \"MPRK43I(0.5,0.75)\"; \"MPDeC(10)\"]\n\n# select methods from OrdinaryDiffEq\nalgs2 = [TRBDF2(); Kvaerno3(); KenCarp3(); Rodas3(); ROS2(); ROS3(); Rosenbrock23()]\nlabels2 = [\"TRBDF2\"; \"Kvearno3\"; \"KenCarp3\"; \"Rodas3\"; \"ROS2\"; \"ROS3\"; \"Rosenbrock23\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error)\n# add work-precision data with isoutofdomain = isnegative\nwork_precision_adaptive!(wp, prob, algs2, labels2, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error, isoutofdomain=isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels2]; title = \"Robertson benchmark\", legend = :topright,\n     color = permutedims([repeat([1], 2)..., 3, 5, repeat([6], 3)..., repeat([7], 4)...]),\n     xlims = (10^-10, 10^3), xticks = 10.0 .^ (-14:1:3),\n     ylims = (10^-6, 10^1), yticks = 10.0 .^ (-6:1:0), minorticks = 10)\n\nWe see that MPRK22(1.0) and MPRK43I(0.5, 0.75) perform similar to Ros3() or Rosenbrock23() and are a good choice as long as low accuracy is acceptable. For high accuracy we should employ a scheme like KenCarp3(). As for MPRK22(0.5) the  superior performance of Rodas3() seems to be an exception here.\n\nIn addition,  we compare the selected MPRK schemes to some recommended solvers of higher order from OrdinaryDiffEq.jl. Again, to guarantee positive solutions we select the solver option isoutofdomain = isnegative.\n\nalgs3 = [Rodas5P(); Rodas4P(); RadauIIA5()]\nlabels3 = [\"Rodas5P\"; \"Rodas4P\"; \"RadauIIA5\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error)\n# add work-precision data with isoutofdomain = isnegative\nwork_precision_adaptive!(wp, prob, algs3, labels3, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error, isoutofdomain=isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels3]; title = \"Robertson benchmark\", legend = :topright,\n     color = permutedims([repeat([1],2)..., 3, 5, repeat([4], 2)..., 6]),\n     xlims = (10^-10, 2*10^0), xticks = 10.0 .^ (-10:1:0),\n     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)\n\nAgain, we see that the MPRK schemes are in general only beneficial if low accuracy is acceptable.","category":"section"},{"location":"robertson_benchmark/#Relative-maximum-error-over-all-time-steps","page":"Robertson problem","title":"Relative maximum error over all time steps","text":"In this section we do not compare the relative maximum errors at the final time t = 10^11, but the relative maximum errors over all time steps.\n\n# select relative maximum error at the end of the problem's time span.\ncompute_error = rel_max_error_overall\nnothing # hide\n\nFirst, we compare different MPRK schemes. As above, we omit SSPMPRK22(0.5, 1.0).\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref;\n                            adaptive_ref = true, compute_error)\n\n# plot work-precision diagram\nplot(wp, labels; title = \"Robertson benchmark\", legend = :outerright,\n     color = permutedims([repeat([1], 3)..., repeat([3], 2)..., repeat([4], 2)..., repeat([5],9)...]),\n     xlims = (10^-4, 5*10^1), xticks = 10.0 .^ (-5:1:2),\n     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)\n\nNotably, the errors of the second-order methods and the MPDeC methods do not decrease when stricter tolerances are used. We choose the second-order scheme MPRK22(1.0) and the third-order scheme MPRK43I(0.5, 0.75) for comparison with solvers from OrdinaryDiffEq.jl. To guarantee nonnegative solutions of these methods, we select the solver option isoutofdomain = isnegative.\n\n# select reference MPRK methods\nalgs1 = [MPRK22(1.0); MPRK43I(0.5, 0.75)]\nlabels1 = [\"MPRK22(1.0)\"; \"MPRK43I(0.5,0.75)\"]\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error)\n# add work-precision data with isoutofdomain = isnegative\nwork_precision_adaptive!(wp, prob, algs2, labels2, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error, isoutofdomain=isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels2]; title = \"Robertson benchmark\", legend = :bottomleft,\n     color = permutedims([1, 3, repeat([5], 3)..., repeat([6], 4)...]),\n     xlims = (10^-5, 10^2), xticks = 10.0 .^ (-14:1:3),\n     ylims = (10^-6, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)\n\nHere too, some methods show that the error does not decrease even though stricter tolerances are used.\n\nFinally, we compare MPRK43I(0.5, 0.75) and MPRK22(1.0) to recommended solvers of higher order from OrdinaryDiffEq.jl. Again, to guarantee positive solutions we select the solver option isoutofdomain = isnegative.\n\n# compute work-precision data\nwp = work_precision_adaptive(prob, algs1, labels1, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error)\n# add work-precision data with isoutofdomain = isnegative\nwork_precision_adaptive!(wp, prob, algs3, labels3, abstols, reltols, alg_ref;\n                               adaptive_ref = true, compute_error, isoutofdomain=isnegative)\n\n# plot work-precision diagram\nplot(wp, [labels1; labels3]; title = \"Robertson benchmark\", legend = :topright,\n     color = permutedims([1, 3, repeat([4], 2)..., 5]),\n     xlims = (10^-4, 2*10^0), xticks = 10.0 .^ (-11:1:0),\n     ylims = (10^-5, 10^0), yticks = 10.0 .^ (-5:1:0), minorticks = 10)","category":"section"},{"location":"robertson_benchmark/#Package-versions","page":"Robertson problem","title":"Package versions","text":"These results were obtained using the following versions.\n\nusing InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"LinearSolve\",\n            \"OrdinaryDiffEqFIRK\", \"OrdinaryDiffEqRosenbrock\",\n            \"OrdinaryDiffEqSDIRK\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"section"},{"location":"heat_equation_dirichlet/#tutorial-heat-equation-dirichlet","page":"Heat Equation, Dirichlet BCs","title":"Tutorial: Solution of the heat equation with Dirichlet boundary conditions","text":"We continue the previous tutorial on solving the heat equation with Neumann boundary conditions by looking at Dirichlet boundary conditions instead, resulting in a non-conservative production-destruction system.","category":"section"},{"location":"heat_equation_dirichlet/#Definition-of-the-(non-conservative)-production-destruction-system","page":"Heat Equation, Dirichlet BCs","title":"Definition of the (non-conservative) production-destruction system","text":"Consider the heat equation\n\npartial_t u(tx) = mu partial_x^2 u(tx)quad u(0x)=u_0(x)\n\nwith μ  0, t 0, xin01, and homogeneous Dirichlet boundary conditions. We use again a finite volume discretization, i.e., we split the domain 0 1 into N uniform cells of width Delta x = 1  N. As degrees of freedom, we use the mean values of u(t) in each cell approximated by the point value u_i(t) in the center of cell i. Finally, we use the classical central finite difference discretization of the Laplacian with homogeneous Dirichlet boundary conditions, resulting in the ODE\n\npartial_t u(t) = L u(t)\nquad\nL = fracmuDelta x^2 beginpmatrix\n    -2  1 \n    1  -2  1 \n     ddots  ddots  ddots \n     1  -2  1 \n     1  -2\nendpmatrix\n\nThe system can be written as a non-conservative PDS with production terms\n\nbeginaligned\np_ii-1(tmathbf u(t)) = fracmuDelta x^2 u_i-1(t)quad i=2dotsN \np_ii+1(tmathbf u(t)) = fracmuDelta x^2 u_i+1(t)quad i=1dotsN-1\nendaligned\n\nand destruction terms d_ij = p_ji for i ne j as well as the non-conservative destruction terms\n\nbeginaligned\nd_11(tmathbf u(t)) = fracmuDelta x^2 u_1(t) \nd_NN(tmathbf u(t)) = fracmuDelta x^2 u_N(t)\nendaligned\n\nIn addition, all production and destruction terms not listed are zero.","category":"section"},{"location":"heat_equation_dirichlet/#Solution-of-the-non-conservative-production-destruction-system","page":"Heat Equation, Dirichlet BCs","title":"Solution of the non-conservative production-destruction system","text":"Now we are ready to define a PDSProblem and to solve this problem with a method of PositiveIntegrators.jl or OrdinaryDiffEq.jl. In the following we use N = 100 nodes and the time domain t in 01. Moreover, we choose the initial condition\n\nu_0(x) = sin(pi x)^2\n\nx_boundaries = range(0, 1, length = 101)\nx = x_boundaries[1:end-1] .+ step(x_boundaries) / 2\nu0 = @. sinpi(x)^2 # initial solution\ntspan = (0.0, 1.0) # time domain\n\nnothing #hide\n\nWe will choose three different matrix types for the production terms and the resulting linear systems:\n\nstandard dense matrices (default)\nsparse matrices (from SparseArrays.jl)\ntridiagonal matrices (from LinearAlgebra.jl)","category":"section"},{"location":"heat_equation_dirichlet/#Standard-dense-matrices","page":"Heat Equation, Dirichlet BCs","title":"Standard dense matrices","text":"using PositiveIntegrators # load ConservativePDSProblem\n\nfunction heat_eq_P!(P, u, μ, t)\n    fill!(P, 0)\n    N = length(u)\n    Δx = 1 / N\n    μ_Δx2 = μ / Δx^2\n\n    let i = 1\n        # Dirichlet boundary condition\n        P[i, i + 1] = u[i + 1] * μ_Δx2\n    end\n\n    for i in 2:(length(u) - 1)\n        # interior stencil\n        P[i, i - 1] = u[i - 1] * μ_Δx2\n        P[i, i + 1] = u[i + 1] * μ_Δx2\n    end\n\n    let i = length(u)\n        # Dirichlet boundary condition\n        P[i, i - 1] = u[i - 1] * μ_Δx2\n    end\n\n    return nothing\nend\n\nfunction heat_eq_D!(D, u, μ, t)\n    fill!(D, 0)\n    N = length(u)\n    Δx = 1 / N\n    μ_Δx2 = μ / Δx^2\n\n    # Dirichlet boundary condition\n    D[begin] = u[begin] * μ_Δx2\n    D[end] = u[end] * μ_Δx2\n\n    return nothing\nend\n\nμ = 1.0e-2\nprob = PDSProblem(heat_eq_P!, heat_eq_D!, u0, tspan, μ) # create the PDS\n\nsol = solve(prob, MPRK22(1.0); save_everystep = false)\n\nnothing #hide\n\nusing Plots\n\nplot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol.u); label = \"u\")","category":"section"},{"location":"heat_equation_dirichlet/#Sparse-matrices","page":"Heat Equation, Dirichlet BCs","title":"Sparse matrices","text":"To use different matrix types for the production terms and linear systems, you can use the keyword argument p_prototype of ConservativePDSProblem and PDSProblem.\n\nusing SparseArrays\np_prototype = spdiagm(-1 => ones(eltype(u0), length(u0) - 1),\n                      +1 => ones(eltype(u0), length(u0) - 1))\nprob_sparse = PDSProblem(heat_eq_P!, heat_eq_D!, u0, tspan, μ;\n                         p_prototype = p_prototype)\n\nsol_sparse = solve(prob_sparse, MPRK22(1.0); save_everystep = false)\n\nnothing #hide\n\nplot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol_sparse.u); label = \"u\")","category":"section"},{"location":"heat_equation_dirichlet/#Tridiagonal-matrices","page":"Heat Equation, Dirichlet BCs","title":"Tridiagonal matrices","text":"The sparse matrices used in this case have a very special structure since they are in fact tridiagonal matrices. Thus, we can also use the special matrix type Tridiagonal from the standard library LinearAlgebra.\n\nusing LinearAlgebra\np_prototype = Tridiagonal(ones(eltype(u0), length(u0) - 1),\n                          ones(eltype(u0), length(u0)),\n                          ones(eltype(u0), length(u0) - 1))\nprob_tridiagonal = PDSProblem(heat_eq_P!, heat_eq_D!, u0, tspan, μ;\n                              p_prototype = p_prototype)\n\nsol_tridiagonal = solve(prob_tridiagonal, MPRK22(1.0); save_everystep = false)\n\nnothing #hide\n\nplot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol_tridiagonal.u); label = \"u\")","category":"section"},{"location":"heat_equation_dirichlet/#Performance-comparison","page":"Heat Equation, Dirichlet BCs","title":"Performance comparison","text":"Finally, we use BenchmarkTools.jl to compare the performance of the different implementations.\n\nusing BenchmarkTools\n@benchmark solve(prob, MPRK22(1.0); save_everystep = false)\n\n@benchmark solve(prob_sparse, MPRK22(1.0); save_everystep = false)\n\nBy default, we use an LU factorization for the linear systems. At the time of writing, Julia uses SparseArrays.jl defaulting to UMFPACK from SuiteSparse in this case. However, the linear systems do not necessarily have the structure for which UMFPACK is optimized  for. Thus, it is often possible to gain performance by switching to KLU  instead.\n\nusing LinearSolve\n@benchmark solve(prob_sparse, MPRK22(1.0; linsolve = KLUFactorization()); save_everystep = false)\n\n@benchmark solve(prob_tridiagonal, MPRK22(1.0); save_everystep = false)","category":"section"},{"location":"heat_equation_dirichlet/#Package-versions","page":"Heat Equation, Dirichlet BCs","title":"Package versions","text":"These results were obtained using the following versions.\n\nusing InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"SparseArrays\", \"KLU\", \"LinearSolve\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"section"},{"location":"robertson/#tutorial-robertson","page":"Robertson problem","title":"Tutorial: Solution of Robertson problem","text":"In this tutorial we show that MPRK schemes can be used to integrate stiff problems. We also show how callbacks can be used to change the time step in non-adaptive schemes.","category":"section"},{"location":"robertson/#Definition-of-the-production-destruction-system","page":"Robertson problem","title":"Definition of the production-destruction system","text":"The well known Robertson problem is given by\n\nbeginaligned\nu_1 = -004u_1+10^4 u_2u_3  u_1(0)=1\nu_2 =  004u_1-10^4 u_2u_3-310^7 u_2^2  u_2(0)=0 \nu_3 = 310^7 u_2^2  u_3(0)=0\nendaligned\n\nThe time domain of interest is tin010^11, because of which some kind of adaptive time stepping is required.\n\nThe model can be represented as a conservative PDS with production terms\n\nbeginaligned\np_12(tmathbfu) = 10^4u_2u_3\np_21(tmathbfu) = 004u_1 \np_32(tmathbfu) = 310^7u_2^2\nendaligned\n\nwhereby production terms not listed have the value zero. Since the PDS is conservative, we have d_ij=p_ji and the system is fully determined by the production matrix mathbf P=(p_ij).","category":"section"},{"location":"robertson/#Solution-of-the-production-destruction-system","page":"Robertson problem","title":"Solution of the production-destruction system","text":"Now we are ready to define a ConservativePDSProblem and to solve this problem with any method of PositiveIntegrators.jl or OrdinaryDiffEq.jl which is suited for stiff problems.\n\nSince this PDS consists of only three differential equations we provide an out-of-place implementation for the production matrix. Furthermore, we use static arrays from StaticArrays.jl for additional efficiency. See also the tutorials on the solution of an NPZD model or an stratospheric reaction problem.\n\nusing PositiveIntegrators, StaticArrays\n\nfunction prod(u, p, t)\n    @SMatrix [0.0 1e4*u[2]*u[3] 0.0;\n              4e-2*u[1] 0.0 0.0;\n              0.0 3e7*u[2]^2 0.0]\nend\nu0 = @SVector [1.0, 0.0, 0.0]\ntspan = (0.0, 1.0e11)\nprob = ConservativePDSProblem(prod, u0, tspan)\n\nsol = solve(prob, MPRK43I(1.0, 0.5))\nnothing  # hide\n\nusing Plots\n\nplot(sol, tspan = (1e-6, 1e11),  xaxis = :log,\n     idxs = [(0, 1), ((x, y) -> (x, 1e4 .* y), 0, 2), (0, 3)],\n     label = [\"u₁\" \"10⁴u₂\" \"u₃\"])\n\nPositiveIntegrators.jl provides the function isnonnegative (and also isnegative) to check if the solution is actually nonnegative, as expected from an MPRK scheme.\n\nisnonnegative(sol)","category":"section"},{"location":"robertson/#Using-callbacks-to-solve-the-Robertson-problem-with-non-adaptive-schemes","page":"Robertson problem","title":"Using callbacks to solve the Robertson problem with non-adaptive schemes","text":"The SSPMPRK43() scheme is only available with fixed time stepping. With a scheme like this, it would take a huge amount of time to solve the Robertson problem, since the time step must be chosen very small to accurately solve the problem in its initial phase. However, the use of a callback allows us to modify the time step size after each step, which makes a solution with a fixed step method possible.\n\nIn the following example the callback increases the time step size by a factor of 1.5 after each time step.\n\nusing DiffEqCallbacks\nusing DiffEqBase\n\nstepsize_callback = DiscreteCallback(\n    Returns(true), # adapt the step size after every time step\n    integrator -> set_proposed_dt!(integrator, 1.5 * get_proposed_dt(integrator));\n    save_positions = (false, false),\n    initialize = (c, u, t, integrator) -> set_proposed_dt!(integrator, 1.0e-5))\nsol_cb = solve(prob, SSPMPRK43(); dt = Inf, callback =  stepsize_callback);\nnothing  # hide\n\nplot(sol_cb, tspan = (1e-6, 1e11),  xaxis = :log,\n     idxs = [(0, 1), ((x, y) -> (x, 1e4 .* y), 0, 2), (0, 3)],\n     label = [\"u₁\" \"10⁴u₂\" \"u₃\"])\n\nThis solution is also nonnegative.\n\nisnonnegative(sol_cb)","category":"section"},{"location":"robertson/#Package-versions","page":"Robertson problem","title":"Package versions","text":"These results were obtained using the following versions.\n\nusing InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"LinearSolve\", \"DiffEqCallbacks\", \"DiffEqBase\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"section"},{"location":"faq/#Troubleshooting-and-frequently-asked-questions","page":"Troubleshooting, FAQ","title":"Troubleshooting and frequently asked questions","text":"","category":"section"},{"location":"faq/#Sparse-matrices","page":"Troubleshooting, FAQ","title":"Sparse matrices","text":"You can use sparse matrices for the linear systems arising in PositiveIntegrators.jl, as described, e.g., in the tutorial on linear advection. However, you need to make sure that you do not change the sparsity pattern of the production term matrix since we assume that the structural nonzeros are kept fixed. This is a known issue. For example, you should avoid something like\n\nusing SparseArrays\np = spdiagm(0 => ones(4), 1 => zeros(3))\np .= 2 * p\n\nInstead, you should be able to use a pattern like the following, where the function nonzeros is used to modify the values of a sparse matrix.\n\nusing SparseArrays\np = spdiagm(0 => ones(4), 1 => zeros(3))\nfor j in axes(p, 2)\n    for idx in nzrange(p, j)\n        i = rowvals(p)[idx]\n        nonzeros(p)[idx] = 10 * i + j # value p[i, j]\n    end\nend; p","category":"section"},{"location":"convergence/#convergence_mprk","page":"Experimental order of convergence","title":"Experimental convergence order of MPRK schemes","text":"In this tutorial, we check that all implemented MPRK schemes can achieve their expected order of convergence. We also address the issue that some methods suffer from order reduction when the solution gets too close to zero.","category":"section"},{"location":"convergence/#Conservative-production-destruction-systems","page":"Experimental order of convergence","title":"Conservative production-destruction systems","text":"First, we consider conservative production-destruction systems (PDS). To investigate the convergence order, we define the non-autonomous test problem \n\nbeginaligned\nu_1 = cos(pi t)^2 u_2 - sin(2pi t)^2 u_1  u_1(0)=09 \nu_2  = sin(2pi t)^2 u_1 - cos(pi t)^2 u_2  u_2(0)=01\nendaligned\n\nfor 0 t 1. The PDS is conservative since the sum of the right-hand side terms equals zero.  An implementation of this problem is given next.\n\nusing PositiveIntegrators\n\n# define problem\nP(u, p, t) = [0.0 cos.(π * t) .^ 2 * u[2]; sin.(2 * π * t) .^ 2 * u[1] 0.0]\nprob = ConservativePDSProblem(P, [0.9; 0.1], (0.0, 1.0))\n\nnothing # hide\n\nTo use analyticless_test_convergence from DiffEqDevTools.jl, we need to pick a solver to compute the reference solution and specify tolerances. Since the problem is not stiff, we use the high-order explicit solver Vern9() from OrdinaryDiffEqVerner.jl.\n\nusing OrdinaryDiffEqVerner\nusing DiffEqDevTools: analyticless_test_convergence\n\n# solver and tolerances to compute reference solution\ntest_setup = Dict(:alg => Vern9(), :reltol => 1e-14, :abstol => 1e-14)\nnothing # hide\n\nTo keep the code short, we also define an auxiliary function that outputs a convergence table, which lists the errors obtained with the respective time step size Δ t as well as the estimated order of convergence in parentheses.\n\nusing Printf: @sprintf\nusing PrettyTables: pretty_table\n\n# auxiliary function\nfunction convergence_table(dts, prob, algs, labels, test_setup)\n    # compute errors and estimated convergence orders\n    err_eoc = []\n    for i in eachindex(algs)\n        sim = analyticless_test_convergence(dts, prob, algs[i], test_setup)\n\n        err = sim.errors[:l∞]\n        eoc = [NaN; -log2.(err[2:end] ./ err[1:(end - 1)])]\n\n        push!(err_eoc, tuple.(err, eoc))\n    end\n\n    # gather data for table\n    data = hcat(dts, reduce(hcat,err_eoc))\n\n    # print table\n    formatter = (v, i, j) ->  (j>1) ? (@sprintf \"%5.2e (%4.2f) \" v[1] v[2]) : (@sprintf \"%5.2e \" v)\n    pretty_table(data; formatters = [formatter], column_labels = [\"Δt\"; labels]) \nend\n\nnothing # hide","category":"section"},{"location":"convergence/#Second-order-and-third-order-MPRK-schemes","page":"Experimental order of convergence","title":"Second-order and third-order MPRK schemes","text":"First, we test several second-order and third-order MPRK schemes.\n\n# choose step sizes\ndts = 0.5 .^ (5:10)\n\n# select 2nd order schemes\nalgs2a = [MPRK22(0.5); MPRK22(2.0 / 3.0); MPRK22(1.0)]\nlabels2a = [\"MPRK22(0.5)\"; \"MPRK22(2.0/3.0)\"; \"MPRK22(1.0)\"]\nalgs2b = [SSPMPRK22(0.5, 1.0); MPDeC(2)]\nlabels2b = [\"SSPMPRK22(0.5, 1.0)\"; \"MPDeC(2)\"]\n\n# select 3rd order schemes\nalgs3a = [MPRK43I(1.0, 0.5); MPRK43I(0.5, 0.75)]\nlabels3a = [\"MPRK43I(1.0,0.5)\"; \"MPRK43I(0.5, 0.75)\"]\nalgs3b = [MPRK43II(0.5); MPRK43II(2.0 / 3.0)]\nlabels3b = [ \"MPRK43II(0.5)\"; \"MPRK43II(2.0/3.0)\"]\nalgs3c = [SSPMPRK43(); MPDeC(3)]\nlabels3c = [\"SSPMPRK43()\"; \"MPDeC(3)\"]\n\nconvergence_table(dts, prob, algs2a, labels2a, test_setup)\nconvergence_table(dts, prob, algs2b, labels2b, test_setup)\n\nconvergence_table(dts, prob, algs3a, labels3a, test_setup)\nconvergence_table(dts, prob, algs3b, labels3b, test_setup)\nconvergence_table(dts, prob, algs3c, labels3c, test_setup)\n\nThe tables show that all schemes converge as expected.","category":"section"},{"location":"convergence/#Higher-order-MPRK-schemes","page":"Experimental order of convergence","title":"Higher-order MPRK schemes","text":"To actually see the order of higher-order methods we need to use more accurate floating-point numbers. Here, we use DoubleFloats.\n\nusing DoubleFloats \n\n# define problem using Double64\nP(u, p, t) = [0 cospi(t)^2 * u[2]; sinpi(2 * t)^2 * u[1] 0]\nu0 = [Double64(9) / 10; Double64(1) / 10]\ntspan = (Double64(0), Double64(1))\nprob_d64 = ConservativePDSProblem(P, u0, tspan)\n\n# choose step sizes\ndts_d64 = Double64(1/2) .^ (5:9)\n\n# select higher-order schemes\nalgs4a = [MPDeC(4); MPDeC(5); MPDeC(6)]\nlabels4a = [\"MPDeC(4)\"; \"MPDeC(5)\"; \"MPDeC(6)\"]\nalgs4b = [MPDeC(7); MPDeC(8)]\nlabels4b = [\"MPDeC(7)\"; \"MPDeC(8)\"]\nalgs4c = [MPDeC(9); MPDeC(10)]\nlabels4c = [\"MPDeC(9)\"; \"MPDeC(10)\"]\n\n# solver and tolerances to compute reference solution\ntest_setup_d64 = Dict(:alg => Vern9(), :reltol => 1e-30, :abstol => 1e-30)\n\n# compute errors and experimental order of convergence\nconvergence_table(dts_d64, prob_d64, algs4a, labels4a, test_setup_d64)\nconvergence_table(dts_d64, prob_d64, algs4b, labels4b, test_setup_d64)\nconvergence_table(dts_d64, prob_d64, algs4c, labels4c, test_setup_d64)\n\nAgain, all schemes show the expected converge order.","category":"section"},{"location":"convergence/#Non-conservative-PDS","page":"Experimental order of convergence","title":"Non-conservative PDS","text":"Next, we consider the non-autonomous but also non-conservative test problem \n\nbeginaligned\nu_1 = cos(pi t)^2 u_2 - sin(2pi t)^2 u_1 - cos(2pi t)^2 u_1  u_1(0)=09\nu_2  = sin(2pi t)^2 u_1 - cos(pi t)^2 u_2 - sin(pi t)^2 u_2  u_2(0)=01\nendaligned\n\nfor 0 t 1. Since the sum of the right-hand side terms does not vanish, the PDS is indeed non-conservative. Hence, we need to use PDSProblem for its implementation.\n\n# PDS\nP(u, p, t) = [0.0 cospi(t)^2 * u[2]; sinpi(2 * t)^2 * u[1] 0.0]\nD(u, p, t) = [cospi(2 * t)^2 * u[1]; sinpi(t)^2 * u[2]]\nprob = PDSProblem(P, D, [0.9; 0.1], (0.0, 1.0))\n\nnothing # hide\n\nThe following tables demonstrate that the chosen MPRK schemes converge as expected also for this non-conservative PDS.","category":"section"},{"location":"convergence/#Second-order-and-third-order-MPRK-schemes-2","page":"Experimental order of convergence","title":"Second-order and third-order MPRK schemes","text":"convergence_table(dts, prob, algs2a, labels2a, test_setup)    \nconvergence_table(dts, prob, algs2b, labels2b, test_setup)\n\nconvergence_table(dts, prob, algs3a, labels3a, test_setup)\nconvergence_table(dts, prob, algs3b, labels3b, test_setup)\nconvergence_table(dts, prob, algs3c, labels3c, test_setup)","category":"section"},{"location":"convergence/#Higher-order-MPRK-schemes-2","page":"Experimental order of convergence","title":"Higher-order MPRK schemes","text":"# problem implementation using DoubleFloats\nP(u, p, t) = [0 cospi(t)^2 * u[2]; sinpi(2 * t)^2 * u[1] 0]\nD(u, p, t) = [cospi(2 * t)^2 * u[1]; sinpi(t)^2 * u[2]]\nprob_d64 = PDSProblem(P, D, [Double64(9)/10; Double64(1)/10], (Double64(0), Double64(1)))\n\nconvergence_table(dts_d64, prob_d64, algs4a, labels4a, test_setup_d64)\nconvergence_table(dts_d64, prob_d64, algs4b, labels4b, test_setup_d64)\nconvergence_table(dts_d64, prob_d64, algs4c, labels4c, test_setup_d64)","category":"section"},{"location":"convergence/#Order-reduction","page":"Experimental order of convergence","title":"Order reduction","text":"It was shown in Torlo, Öffner, Ranocha: Issues with positivity-preserving Patankar-type schemes with positivity-preserving Patankar-type schemes that some MPRK methods  suffer from order reduction if the solution of the PDS is too close to zero. We demonstrate this by solving a problem where one component of the initial condition is equal to zero. \n\nThe problem is\n\nbeginaligned\nu_1 = -u_1  u_1(0)=1 \nu_2  = u_1  u_2(0)=0\nendaligned\n\nfor 0 t 1 and can be implemented as follows.\n\n# PDS\nP(u, p, t) = [0 0; u[1] 0]\nprob = ConservativePDSProblem(P, [1.0; 0.0], (0.0, 1.0))\nnothing # hide\n\nNext, we generate the corresponding convergence tables as in the sections above.\n\ntest_setup = Dict(:alg => Vern9(), :reltol => 1e-14, :abstol => 1e-14)\n\ndts = 0.5 .^ (6:12)\n\nconvergence_table(dts, prob, algs2a, labels2a, test_setup)\nconvergence_table(dts, prob, algs2b, labels2b, test_setup)\n\nconvergence_table(dts, prob, algs3a, labels3a, test_setup)\nconvergence_table(dts, prob, algs3b, labels3b, test_setup)\nconvergence_table(dts, prob, algs3c, labels3c, test_setup)\n\nconvergence_table(dts, prob, algs4a, labels4a, test_setup)\nconvergence_table(dts, prob, algs4b, labels4b, test_setup)\nconvergence_table(dts, prob, algs4c, labels4c, test_setup) \nnothing # hide\n\nWe find that all methods apart from MPDeC(K) methods with K  3 converge as expected. The MPDeC(K) methods with K  3 suffer from order reduction and show convergence order 2 instead of K.","category":"section"},{"location":"heat_equation_neumann/#tutorial-heat-equation-neumann","page":"Heat Equation, Neumann BCs","title":"Tutorial: Solution of the heat equation with Neumann boundary conditions","text":"Similar to the tutorial on linear advection, we will demonstrate how to solve a conservative production-destruction system (PDS) resulting from a PDE discretization and means to improve the performance.","category":"section"},{"location":"heat_equation_neumann/#Definition-of-the-conservative-production-destruction-system","page":"Heat Equation, Neumann BCs","title":"Definition of the conservative production-destruction system","text":"Consider the heat equation\n\npartial_t u(tx) = mu partial_x^2 u(tx)quad u(0x)=u_0(x)\n\nwith μ  0, t 0, xin01, and homogeneous Neumann boundary conditions. We use a finite volume discretization, i.e., we split the domain 0 1 into N uniform cells of width Delta x = 1  N. As degrees of freedom, we use the mean values of u(t) in each cell approximated by the point value u_i(t) in the center of cell i. Finally, we use the classical central finite difference discretization of the Laplacian with homogeneous Neumann boundary conditions, resulting in the ODE\n\npartial_t u(t) = L u(t)\nquad\nL = fracmuDelta x^2 beginpmatrix\n    -1  1 \n    1  -2  1 \n     ddots  ddots  ddots \n     1  -2  1 \n     1  -1\nendpmatrix\n\nThe system can be written as a conservative PDS with production terms\n\nbeginaligned\np_ii-1(tmathbf u(t)) = fracmuDelta x^2 u_i-1(t)quad i=2dotsN \np_ii+1(tmathbf u(t)) = fracmuDelta x^2 u_i+1(t)quad i=1dotsN-1\nendaligned\n\nand destruction terms d_ij = p_ji. In addition, all production and destruction terms not listed are zero.","category":"section"},{"location":"heat_equation_neumann/#Solution-of-the-conservative-production-destruction-system","page":"Heat Equation, Neumann BCs","title":"Solution of the conservative production-destruction system","text":"Now we are ready to define a ConservativePDSProblem and to solve this problem with a method of PositiveIntegrators.jl or OrdinaryDiffEq.jl. In the following we use N = 100 nodes and the time domain t in 01. Moreover, we choose the initial condition\n\nu_0(x) = cos(pi x)^2\n\nx_boundaries = range(0, 1, length = 101)\nx = x_boundaries[1:end-1] .+ step(x_boundaries) / 2\nu0 = @. cospi(x)^2 # initial solution\ntspan = (0.0, 1.0) # time domain\n\nnothing #hide\n\nWe will choose three different matrix types for the production terms and the resulting linear systems:\n\nstandard dense matrices (default)\nsparse matrices (from SparseArrays.jl)\ntridiagonal matrices (from LinearAlgebra.jl)","category":"section"},{"location":"heat_equation_neumann/#Standard-dense-matrices","page":"Heat Equation, Neumann BCs","title":"Standard dense matrices","text":"using PositiveIntegrators # load ConservativePDSProblem\n\nfunction heat_eq_P!(P, u, μ, t)\n    fill!(P, 0)\n    N = length(u)\n    Δx = 1 / N\n    μ_Δx2 = μ / Δx^2\n\n    let i = 1\n        # Neumann boundary condition\n        P[i, i + 1] = u[i + 1] * μ_Δx2\n    end\n\n    for i in 2:(length(u) - 1)\n        # interior stencil\n        P[i, i - 1] = u[i - 1] * μ_Δx2\n        P[i, i + 1] = u[i + 1] * μ_Δx2\n    end\n\n    let i = length(u)\n        # Neumann boundary condition\n        P[i, i - 1] = u[i - 1] * μ_Δx2\n    end\n\n    return nothing\nend\n\nμ = 1.0e-2\nprob = ConservativePDSProblem(heat_eq_P!, u0, tspan, μ) # create the PDS\n\nsol = solve(prob, MPRK22(1.0); save_everystep = false)\n\nnothing #hide\n\nusing Plots\n\nplot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol.u); label = \"u\")","category":"section"},{"location":"heat_equation_neumann/#Sparse-matrices","page":"Heat Equation, Neumann BCs","title":"Sparse matrices","text":"To use different matrix types for the production terms and linear systems, you can use the keyword argument p_prototype of ConservativePDSProblem and PDSProblem.\n\nusing SparseArrays\np_prototype = spdiagm(-1 => ones(eltype(u0), length(u0) - 1),\n                      +1 => ones(eltype(u0), length(u0) - 1))\nprob_sparse = ConservativePDSProblem(heat_eq_P!, u0, tspan, μ;\n                                     p_prototype = p_prototype)\n\nsol_sparse = solve(prob_sparse, MPRK22(1.0); save_everystep = false)\n\nnothing #hide\n\nplot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol_sparse.u); label = \"u\")","category":"section"},{"location":"heat_equation_neumann/#Tridiagonal-matrices","page":"Heat Equation, Neumann BCs","title":"Tridiagonal matrices","text":"The sparse matrices used in this case have a very special structure since they are in fact tridiagonal matrices. Thus, we can also use the special matrix type Tridiagonal from the standard library LinearAlgebra.\n\nusing LinearAlgebra\np_prototype = Tridiagonal(ones(eltype(u0), length(u0) - 1),\n                          ones(eltype(u0), length(u0)),\n                          ones(eltype(u0), length(u0) - 1))\nprob_tridiagonal = ConservativePDSProblem(heat_eq_P!, u0, tspan, μ;\n                                          p_prototype = p_prototype)\n\nsol_tridiagonal = solve(prob_tridiagonal, MPRK22(1.0); save_everystep = false)\n\nnothing #hide\n\nplot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol_tridiagonal.u); label = \"u\")","category":"section"},{"location":"heat_equation_neumann/#Performance-comparison","page":"Heat Equation, Neumann BCs","title":"Performance comparison","text":"Finally, we use BenchmarkTools.jl to compare the performance of the different implementations.\n\nusing BenchmarkTools\n@benchmark solve(prob, MPRK22(1.0); save_everystep = false)\n\n@benchmark solve(prob_sparse, MPRK22(1.0); save_everystep = false)\n\nBy default, we use an LU factorization for the linear systems. At the time of writing, Julia uses SparseArrays.jl defaulting to UMFPACK from SuiteSparse in this case. However, the linear systems do not necessarily have the structure for which UMFPACK is optimized  for. Thus, it is often possible to gain performance by switching to KLU  instead.\n\nusing LinearSolve\n@benchmark solve(prob_sparse, MPRK22(1.0; linsolve = KLUFactorization()); save_everystep = false)\n\n@benchmark solve(prob_tridiagonal, MPRK22(1.0); save_everystep = false)","category":"section"},{"location":"heat_equation_neumann/#Package-versions","page":"Heat Equation, Neumann BCs","title":"Package versions","text":"These results were obtained using the following versions.\n\nusing InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"SparseArrays\", \"KLU\", \"LinearSolve\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"section"},{"location":"code_of_conduct/#code-of-conduct","page":"Code of conduct","title":"Code of Conduct","text":"Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our community include:Demonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to Stefan Kopecz or Hendrik Ranocha. All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series of actions.Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within the community.AttributionThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0, available at https://www.contributor-covenant.org/version/2/0/codeofconduct.html.Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.[homepage]: https://www.contributor-covenant.orgFor answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","category":"section"},{"location":"linear_advection/#tutorial-linear-advection","page":"Linear Advection","title":"Tutorial: Solution of the linear advection equation","text":"This tutorial is about the efficient solution of production-destruction systems (PDS) with a large number of differential equations. We will explore several ways to represent such large systems and assess their efficiency.","category":"section"},{"location":"linear_advection/#Definition-of-the-production-destruction-system","page":"Linear Advection","title":"Definition of the production-destruction system","text":"One example of the occurrence of a PDS with a large number of equations is the space discretization of a partial differential equation. In this tutorial we want to solve the linear advection equation\n\npartial_t u(tx)=-apartial_x u(tx)quad u(0x)=u_0(x)\n\nwith a0, t 0, xin01 and periodic boundary conditions. To keep things as simple as possible, we discretize the space domain as 0=x_0x_1dots x_N-1x_N=1 with x_i = i Δ x for i=0dotsN and Δx=1N. An upwind discretization of the spatial derivative yields the ODE system\n\nbeginaligned\npartial_t u_1(t) =-fracaΔxbigl(u_1(t)-u_N(t)bigr)\npartial_t u_i(t) =-fracaΔxbigl(u_i(t)-u_i-1(t)bigr)quad i=2dotsN\nendaligned\n\nwhere u_i(t) is an approximation of u(tx_i) for i=1dots N. This system can also be written as partial_t mathbf u(t)=mathbf Amathbf u(t) with mathbf u(t)=(u_1(t)dotsu_N(t)) and\n\nmathbf A= fracaΔ xbeginbmatrix-10dots011-1ddots00ddotsddotsddotsvdots vdotsddotsddotsddots00dots01-1endbmatrix\n\nIn particular the matrix mathbf A shows that there is a single production term and a single destruction term per equation. Furthermore, the system is conservative as mathbf A has column sum zero. To be precise, the production matrix mathbf P = (p_ij) of this conservative PDS is given by\n\nbeginaligned\np_1N(tmathbf u(t)) = fracaΔ xu_N(t)\np_ii-1(tmathbf u(t)) = fracaΔ xu_i-1(t)quad i=2dotsN\nendaligned\n\nIn addition, all production and destruction terms not listed have the value zero. Since the PDS is conservative, we have d_ij=p_ji and the system is fully determined by the production matrix mathbf P.","category":"section"},{"location":"linear_advection/#Solution-of-the-production-destruction-system","page":"Linear Advection","title":"Solution of the production-destruction system","text":"Now we are ready to define a ConservativePDSProblem and to solve this problem with a method of PositiveIntegrators.jl or OrdinaryDiffEq.jl. In the following we use a=1, N=1000 and the time domain tin01. Moreover, we choose the step function\n\nu_0(x)=begincases1  04  x  06 0 textelsewhereendcases\n\nas initial condition. Due to the periodic boundary conditions and the transport velocity a=1, the solution at time t=1 is identical to the initial distribution, i.e. u(1x) = u_0(x).\n\nN = 1000 # number of subintervals\ndx = 1/N # mesh width\nx = LinRange(dx, 1.0, N) # discretization points x_1,...,x_N = x_0\nu0 = @. 0.0 + (0.4 ≤ x ≤ 0.6) * 1.0 # initial solution\ntspan = (0.0, 1.0) # time domain\n\nnothing #hide\n\nAs mentioned above, we will try different approaches to solve this PDS and compare their efficiency. These are\n\nan in-place implementation with a dense matrix,\nan in-place implementation with a sparse matrix.","category":"section"},{"location":"linear_advection/#Standard-in-place-implementation","page":"Linear Advection","title":"Standard in-place implementation","text":"By default, we will use dense matrices to store the production terms and to setup/solve the linear systems arising in MPRK methods. Of course, this is not efficient for large and sparse systems like in this case.\n\nusing PositiveIntegrators # load ConservativePDSProblem\n\nfunction lin_adv_P!(P, u, p, t)\n    fill!(P, 0.0)\n    N = length(u)\n    dx = 1 / N\n    P[1, N] = u[N] / dx\n    for i in 2:N\n        P[i, i - 1] = u[i - 1] / dx\n    end\n    return nothing\nend\n\nprob = ConservativePDSProblem(lin_adv_P!, u0, tspan) # create the PDS\n\nsol = solve(prob, MPRK43I(1.0, 0.5); save_everystep = false)\n\nnothing #hide\n\nusing Plots\n\nplot(x, u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol.u); label = \"u\")\n\nWe can use isnonnegative to check that the computed solution is nonnegative,  as expected from an MPRK scheme.\n\nisnonnegative(sol)","category":"section"},{"location":"linear_advection/#Using-sparse-matrices","page":"Linear Advection","title":"Using sparse matrices","text":"To use different matrix types for the production terms and linear systems, we can use the keyword argument p_prototype of ConservativePDSProblem and PDSProblem.\n\nusing SparseArrays\np_prototype = spdiagm(-1 => ones(eltype(u0), N - 1),\n                      N - 1 => ones(eltype(u0), 1))\nprob_sparse = ConservativePDSProblem(lin_adv_P!, u0, tspan; p_prototype=p_prototype)\n\nsol_sparse = solve(prob_sparse, MPRK43I(1.0, 0.5); save_everystep = false)\n\nnothing #hide\n\nplot(x,u0; label = \"u0\", xguide = \"x\", yguide = \"u\")\nplot!(x, last(sol_sparse.u); label = \"u\")\n\nAlso this solution is nonnegative.\n\nisnonnegative(sol_sparse)","category":"section"},{"location":"linear_advection/#Performance-comparison","page":"Linear Advection","title":"Performance comparison","text":"Finally, we use BenchmarkTools.jl to compare the performance of the different implementations.\n\nusing BenchmarkTools\n@benchmark solve(prob, MPRK43I(1.0, 0.5); save_everystep = false)\n\n@benchmark solve(prob_sparse, MPRK43I(1.0, 0.5); save_everystep = false)\n\nBy default, we use an LU factorization for the linear systems. At the time of writing, Julia uses SparseArrays.jl defaulting to UMFPACK from SuiteSparse in this case. However, the linear systems do not necessarily have the structure for which UMFPACK is optimized for. Thus, it is often possible to gain performance by switching to KLU instead.\n\nusing LinearSolve\n@benchmark solve(prob_sparse, MPRK43I(1.0, 0.5; linsolve = KLUFactorization()); save_everystep = false)","category":"section"},{"location":"linear_advection/#Package-versions","page":"Linear Advection","title":"Package versions","text":"These results were obtained using the following versions.\n\nusing InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"SparseArrays\", \"KLU\", \"LinearSolve\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"section"},{"location":"stratospheric_reaction/#tutorial-stratos","page":"Stratospheric reaction problem","title":"Tutorial: Solution of a stratospheric reaction problem","text":"This tutorial is about the efficient solution of a stiff non-autonomous and non-conservative production-destruction systems (PDS) with a small number of differential equations. We will compare the use of standard arrays and static arrays from StaticArrays.jl and assess their efficiency.","category":"section"},{"location":"stratospheric_reaction/#Definition-of-the-production-destruction-system","page":"Stratospheric reaction problem","title":"Definition of the production-destruction system","text":"This stratospheric reaction problem was described by Adrian Sandu in Positive Numerical Integration Methods for Chemical Kinetic Systems, see also the paper Positivity-preserving adaptive Runge–Kutta methods by Stefan Nüßlein, Hendrik Ranocha and David I. Ketcheson. The governing equations are\n\nbeginaligned\nfracdO^1Ddt = r_5 - r_6 -  r_7\nfracdOdt = 2r_1 - r_2 + r_3 - r_4 + r_6 - r_9 + r_10 - r_11\nfracdO_3dt = r_2 - r_3 - r_4 - r_5 - r_7 - r_8\nfracdO_2dt = -r_1 -r_2 + r_3 + 2r_4+r_5+2r_7+r_8+r_9\nfracdNOdt = -r_8+r_9+r_10-r_11\nfracdNO_2dt = r_8-r_9-r_10+r_11\nendaligned\n\nwith reaction rates\n\nbeginaligned\nr_1 =2643 10^-10σ^3 O_2  r_2 =801810^-17O O_2   r_3 =61210^-4σ O_3\nr_4 =156710^-15O_3 O   r_5 = 107 10^-3σ^2O_3   r_6 = 71110^-11 81210^6 O^1D\nr_7 = 1210^-10O^1D O_3  r_8 = 606210^-15O_3 NO  r_9 = 106910^-11NO_2 O\nr_10 = 128910^-2σ NO_2  r_11 = 10^-8NO O\nendaligned\n\nwhere\n\nbeginaligned\nT = t3600 mod 24quad T_r=45quad T_s = 195\nσ(T) = begincases1  T_r T T_s0  textotherwiseendcases\nendaligned\n\nSetting mathbf u = (O^1D O O_3 O_2 NO NO_2) the initial value is mathbfu_0 = (990610^1 662410^8 532610^11 169710^16 410^6 109310^9)^T. The time domain in seconds is 43210^4 302410^5, which corresponds to 120 840 in hours. There are two independent linear invariants, e.g. u_1+u_2+3u_3+2u_4+u_5+2u_6=(113212)cdotmathbfu_0 and u_5+u_6 = 109710^9.\n\nThe stratospheric reaction problem can be represented as a (non-conservative) PDS with production terms\n\nbeginaligned\np_13 = r_5  p_21 = r_6  p_22 = r_1+r_10\np_23 = r_3  p_24 = r_1 p_32 = r_2\np_41 = r_7  p_42= r_4+r_9  p_43= r_4+r_7+r_8\np_44 = r_3+r_5  p_56=r_9+r_10  p_65=r_8+r_11\nendaligned\n\nand additional destruction terms\n\nbeginaligned\nd_22= r_11  d_44=r_2\nendaligned\n\nIn addition, all production and destruction terms not listed have the value zero.","category":"section"},{"location":"stratospheric_reaction/#Solution-of-the-production-destruction-system","page":"Stratospheric reaction problem","title":"Solution of the production-destruction system","text":"Now we are ready to define a PDSProblem and to solve this problem with a method of PositiveIntegrators.jl or OrdinaryDiffEq.jl.\n\nAs mentioned above, we will try different approaches to solve this PDS and compare their efficiency. These are\n\nan out-of-place implementation with standard (dynamic) matrices and vectors,\nan in-place implementation with standard (dynamic) matrices and vectors,\nan out-of-place implementation with static matrices and vectors from StaticArrays.jl.","category":"section"},{"location":"stratospheric_reaction/#Standard-out-of-place-implementation","page":"Stratospheric reaction problem","title":"Standard out-of-place implementation","text":"Here we create an out-of-place function to compute the production matrix with return type Matrix{Float64} and a second out-of-place function for the destruction vector with return type Vector{Float64}.\n\nusing PositiveIntegrators # load PDSProblem\n\nfunction prod(u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    Tr = 4.5\n    Ts = 19.5\n    T = mod(t / 3600, 24)\n    if (Tr <= T) && (T <= Ts)\n        Tfrac = (2 * T - Tr - Ts) / (Ts - Tr)\n        sigma = 0.5 + 0.5 * cos(pi * abs(Tfrac) * Tfrac)\n    else\n        sigma = 0.0\n    end\n\n    M = 8.120e16\n\n    k1 = 2.643e-10 * sigma^3\n    k2 = 8.018e-17\n    k3 = 6.120e-4 * sigma\n    k4 = 1.567e-15\n    k5 = 1.070e-3 * sigma^2\n    k6 = 7.110e-11\n    k7 = 1.200e-10\n    k8 = 6.062e-15\n    k9 = 1.069e-11\n    k10 = 1.289e-2 * sigma\n    k11 = 1.0e-8\n\n    r1 = k1 * O2\n    r2 = k2 * O * O2\n    r3 = k3 * O3\n    r4 = k4 * O3 * O\n    r5 = k5 * O3\n    r6 = k6 * M * O1D\n    r7 = k7 * O1D * O3\n    r8 = k8 * O3 * NO\n    r9 = k9 * NO2 * O\n    r10 = k10 * NO2\n    r11 = k11 * NO * O\n\n    return [0.0 0.0 r5 0.0 0.0 0.0;\n            r6 r1+r10 r3 r1 0.0 0.0;\n            0.0 r2 0.0 0.0 0.0 0.0;\n            r7 r4+r9 r4+r7+r8 r3+r5 0.0 0.0;\n            0.0 0.0 0.0 0.0 0.0 r9+r10;\n            0.0 0.0 0.0 0.0 r8+r11 0.0]\nend\n\nfunction dest(u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    k2 = 8.018e-17\n    k11 = 1.0e-8\n\n    r2 = k2 * O * O2\n    r11 = k11 * NO * O\n\n    return [0.0, r11, 0.0, r2, 0.0, 0.0]\nend\nnothing #hide\n\nThe solution of the stratospheric reaction problem can now be computed as follows.\n\nu0 = [9.906e1, 6.624e8, 5.326e11, 1.697e16, 4e6, 1.093e9] # initial values\ntspan = (4.32e4, 3.024e5) # time domain\nprob_oop = PDSProblem(prod, dest, u0, tspan) # create the PDS\n\nsol_oop = solve(prob_oop, MPRK43I(1.0, 0.5))\n\nnothing #hide\n\nPlotting the solution shows that the components O¹ᴰ, O and NO are in danger of becoming negative.\n\nusing Plots\n\nplot(sol_oop,\n    layout=(3,2),\n    xguide = \"t [h]\",\n    xguidefontsize = 8,\n    xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4)),\n    yguide=[\"O¹ᴰ\" \"O\" \"O₃\" \"O₂\" \"NO\" \"NO₂\"],\n    tickfontsize = 7,\n    legend = :none,\n    widen = true\n    )\n\nPositiveIntegrators.jl provides the function isnonnegative (and also isnegative) to check if the solution is actually nonnegative, as expected from an MPRK scheme.\n\nisnonnegative(sol_oop)","category":"section"},{"location":"stratospheric_reaction/#Standard-in-place-implementation","page":"Stratospheric reaction problem","title":"Standard in-place implementation","text":"Next we create in-place functions for the production matrix and the destruction vector.\n\n\nfunction prod!(P, u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    Tr = 4.5\n    Ts = 19.5\n    T = mod(t / 3600, 24)\n    if (Tr <= T) && (T <= Ts)\n        Tfrac = (2 * T - Tr - Ts) / (Ts - Tr)\n        sigma = 0.5 + 0.5 * cos(pi * abs(Tfrac) * Tfrac)\n    else\n        sigma = 0.0\n    end\n\n    M = 8.120e16\n\n    k1 = 2.643e-10 * sigma^3\n    k2 = 8.018e-17\n    k3 = 6.120e-4 * sigma\n    k4 = 1.567e-15\n    k5 = 1.070e-3 * sigma^2\n    k6 = 7.110e-11\n    k7 = 1.200e-10\n    k8 = 6.062e-15\n    k9 = 1.069e-11\n    k10 = 1.289e-2 * sigma\n    k11 = 1.0e-8\n\n    r1 = k1 * O2\n    r2 = k2 * O * O2\n    r3 = k3 * O3\n    r4 = k4 * O3 * O\n    r5 = k5 * O3\n    r6 = k6 * M * O1D\n    r7 = k7 * O1D * O3\n    r8 = k8 * O3 * NO\n    r9 = k9 * NO2 * O\n    r10 = k10 * NO2\n    r11 = k11 * NO * O\n\n    fill!(P, zero(eltype(P)))\n    P[1, 3] = r5\n    P[2, 1] = r6\n    P[2, 2] = r1 + r10\n    P[2, 3] = r3\n    P[2, 4] = r1\n    P[3, 2] = r2\n    P[4, 1] = r7\n    P[4, 2] = r4 + r9\n    P[4, 3] = r4 + r7 + r8\n    P[4, 4] = r3 + r5\n    P[5, 6] = r9 + r10\n    P[6, 5] = r8 + r11\n    return nothing\nend\n\nfunction dest!(D, u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    k2 = 8.018e-17\n    k11 = 1.0e-8\n\n    r2 = k2 * O * O2\n    r11 = k11 * NO * O\n\n    fill!(D, zero(eltype(D)))\n\n    D[2] = r11\n    D[4] = r2\n\n    return nothing\nend\nnothing #hide\n\nThe solution of the in-place implementation of the stratospheric reaction problem can now be computed as follows.\n\n\nprob_ip = PDSProblem(prod!, dest!, u0, tspan) # create the PDS\nsol_ip = solve(prob_ip, MPRK43I(1.0, 0.5))\nnothing #hide\n\n\nplot(sol_ip,\n    layout=(3,2),\n    xguide = \"t [h]\",\n    xguidefontsize = 8,\n    xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4)),\n    yguide=[\"O¹ᴰ\" \"O\" \"O₃\" \"O₂\" \"NO\" \"NO₂\"],\n    tickfontsize = 7,\n    legend = :none,\n    widen = true\n    )\n\nWe also check that the in-place and out-of-place solutions are equivalent.\n\nsol_oop.t ≈ sol_ip.t && sol_oop.u ≈ sol_ip.u","category":"section"},{"location":"stratospheric_reaction/#Using-static-arrays","page":"Stratospheric reaction problem","title":"Using static arrays","text":"For PDS with a small number of differential equations like the stratospheric reaction model the use of static arrays will be more efficient. To create a function which computes the production matrix and returns a static matrix, we only need to add the @SMatrix macro. Accordingly, we use the @SVector macro for the destruction vector.\n\nusing StaticArrays\n\nfunction prod_static(u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    Tr = 4.5\n    Ts = 19.5\n    T = mod(t / 3600, 24)\n    if (Tr <= T) && (T <= Ts)\n        Tfrac = (2 * T - Tr - Ts) / (Ts - Tr)\n        sigma = 0.5 + 0.5 * cos(pi * abs(Tfrac) * Tfrac)\n    else\n        sigma = 0.0\n    end\n\n    M = 8.120e16\n\n    k1 = 2.643e-10 * sigma^3\n    k2 = 8.018e-17\n    k3 = 6.120e-4 * sigma\n    k4 = 1.567e-15\n    k5 = 1.070e-3 * sigma^2\n    k6 = 7.110e-11\n    k7 = 1.200e-10\n    k8 = 6.062e-15\n    k9 = 1.069e-11\n    k10 = 1.289e-2 * sigma\n    k11 = 1.0e-8\n\n    r1 = k1 * O2\n    r2 = k2 * O * O2\n    r3 = k3 * O3\n    r4 = k4 * O3 * O\n    r5 = k5 * O3\n    r6 = k6 * M * O1D\n    r7 = k7 * O1D * O3\n    r8 = k8 * O3 * NO\n    r9 = k9 * NO2 * O\n    r10 = k10 * NO2\n    r11 = k11 * NO * O\n\n    return @SMatrix [0.0 0.0 r5 0.0 0.0 0.0;\n            r6 r1+r10 r3 r1 0.0 0.0;\n            0.0 r2 0.0 0.0 0.0 0.0;\n            r7 r4+r9 r4+r7+r8 r3+r5 0.0 0.0;\n            0.0 0.0 0.0 0.0 0.0 r9+r10;\n            0.0 0.0 0.0 0.0 r8+r11 0.0]\nend\n\nfunction dest_static(u, p, t)\n    O1D, O, O3, O2, NO, NO2 = u\n\n    k2 = 8.018e-17\n    k11 = 1.0e-8\n\n    r2 = k2 * O * O2\n    r11 = k11 * NO * O\n\n    return @SVector [0.0, r11, 0.0, r2, 0.0, 0.0]\nend\nnothing #hide\n\nIn addition we also want to use a static vector to hold the initial conditions.\n\nu0_static = @SVector [9.906e1, 6.624e8, 5.326e11, 1.697e16, 4e6, 1.093e9] # initial values\nprob_static = PDSProblem(prod_static, dest_static, u0_static, tspan) # create the PDS\n\nsol_static = solve(prob_static, MPRK43I(1.0, 0.5))\n\nnothing #hide\n\nThis solution is also nonnegative.\n\nisnonnegative(sol_static)\n\nusing Plots\n\nplot(sol_static,\n    layout=(3,2),\n    xguide = \"t [h]\",\n    xguidefontsize = 8,\n    xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4)),\n    yguide=[\"O¹ᴰ\" \"O\" \"O₃\" \"O₂\" \"NO\" \"NO₂\"],\n    tickfontsize = 7,\n    legend = :none,\n    widen = true\n    )\n\nThe above implementation of the stratospheric reaction problem using StaticArrays can also be found in the Example Problems as prob_pds_stratreac.","category":"section"},{"location":"stratospheric_reaction/#Preservation-of-linear-invariants","page":"Stratospheric reaction problem","title":"Preservation of linear invariants","text":"As MPRK schemes do not preserve general linear invariants, especially when applied to non-conservative PDS, we compute and plot the relative errors with respect to both linear invariants to see how well these are preserved.\n\nlinear_invariant(a, u) = sum(a .* u)\n\nfunction relerr_lininv(a, u0, sol)\n    c = linear_invariant(a, u0)\n    return abs.(c .- (x -> linear_invariant(a, x)).(sol.u))./c\nend\n\na1 = [1; 1; 3; 2; 1; 2] # first linear invariant\na2 = [0; 0; 0; 0; 1; 1] # second linear invariant\n\np1 = plot(sol_oop.t, relerr_lininv(a1, u0, sol_oop))\np2 = plot(sol_oop.t, relerr_lininv(a2, u0, sol_oop))\nplot(p1, p2,\n    xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4)),\n    legend = :none)\n\nIn contrast to MPRK schemes, Runge-Kutta and Rosenbrock methods preserve all linear invariants, but are not guaranteed to generate nonnegative solutions. One way to enforce nonnegative solutions of such schemes is passing isnegative to the solver option isoutofdomain. We show this using the Rosenbrock scheme Rosenbrock23 as an example.\n\nusing OrdinaryDiffEqRosenbrock\n\nsol_tmp = solve(prob_oop, Rosenbrock23());\nisnonnegative(sol_tmp)\n\nsol_Ros23 = solve(prob_oop, Rosenbrock23(), isoutofdomain = isnegative);\nisnonnegative(sol_Ros23)\n\np3 = plot(sol_Ros23.t, relerr_lininv(a1, u0, sol_Ros23))\np4 = plot(sol_Ros23.t, relerr_lininv(a2, u0, sol_Ros23))\nplot(p3, p4,\n     xticks = (range(first(tspan), last(tspan), 4), range(12.0, 84.0, 4)),\n     legend = :none)","category":"section"},{"location":"stratospheric_reaction/#Performance-comparison","page":"Stratospheric reaction problem","title":"Performance comparison","text":"Finally, we use BenchmarkTools.jl to compare the different implementations and to show the benefit of using static arrays.\n\nusing BenchmarkTools\n@benchmark solve(prob_oop, MPRK43I(1.0, 0.5))\n\nusing BenchmarkTools\n@benchmark solve(prob_ip, MPRK43I(1.0, 0.5))\n\n@benchmark solve(prob_static, MPRK43I(1.0, 0.5))","category":"section"},{"location":"stratospheric_reaction/#Package-versions","page":"Stratospheric reaction problem","title":"Package versions","text":"These results were obtained using the following versions.\n\nusing InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"LinearSolve\", \"OrdnaryDiffEqRosenbrock\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"section"},{"location":"api_reference/#PositiveIntegrators.jl-API","page":"API reference","title":"PositiveIntegrators.jl API","text":"","category":"section"},{"location":"api_reference/#Problem-types","page":"API reference","title":"Problem types","text":"","category":"section"},{"location":"api_reference/#Example-problems","page":"API reference","title":"Example problems","text":"","category":"section"},{"location":"api_reference/#Algorithms","page":"API reference","title":"Algorithms","text":"","category":"section"},{"location":"api_reference/#Callbacks","page":"API reference","title":"Callbacks","text":"","category":"section"},{"location":"api_reference/#Auxiliary-functions","page":"API reference","title":"Auxiliary functions","text":"","category":"section"},{"location":"api_reference/#PositiveIntegrators.ConservativePDSProblem","page":"API reference","title":"PositiveIntegrators.ConservativePDSProblem","text":"ConservativePDSProblem(P, u0, tspan, p = NullParameters();\n                       p_prototype = nothing,\n                       analytic = nothing,\n                       std_rhs = nothing,\n                       linear_invariants = nothing)\n\nA structure describing a conservative system of ordinary differential equation in form of a production-destruction system (PDS). P denotes the function defining the production matrix P. The diagonal of P contains production terms without destruction counterparts. u0 is the vector of initial conditions and tspan the time span (t_initial, t_final) of the problem. The optional argument p can be used to pass additional parameters to the function P.\n\nThe function P can be given either in the out-of-place form with signature production_terms = P(u, p, t) or the in-place form P(production_terms, u, p, t).\n\nKeyword arguments:\n\np_prototype: If P is given in in-place form, p_prototype or copies thereof are used to store evaluations of P. If p_prototype is not specified explicitly and P is in-place, then p_prototype will be internally set to zeros(eltype(u0), (length(u0), length(u0))).\nanalytic: The analytic solution of a PDS must be given in the form f(u0,p,t). Specifying the analytic solution can be useful for plotting and convergence tests.\nstd_rhs: The standard ODE right-hand side evaluation function callable as du = std_rhs(u, p, t) for the out-of-place form and as std_rhs(du, u, p, t) for the in-place form. Solvers that do not rely on the production-destruction representation of the ODE, will use this function instead to compute the solution. If not specified, a default implementation calling P is used\nlinear_invariants: The rows of this matrix contain the linear invariants of the ODE.  Certain solvers or callbacks require this matrix. Note that this feature is experimental and its API may change in future releases.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.PDSProblem","page":"API reference","title":"PositiveIntegrators.PDSProblem","text":"PDSProblem(P, D, u0, tspan, p = NullParameters();\n           p_prototype = nothing,\n           analytic = nothing,\n           std_rhs = nothing,\n           linear_invariants = nothing)\n\nA structure describing a system of ordinary differential equations in form of a production-destruction system (PDS). P denotes the function defining the production matrix P. The diagonal of P contains production terms without destruction counterparts. D is the function defining the vector of destruction terms D without production counterparts. u0 is the vector of initial conditions and tspan the time span (t_initial, t_final) of the problem. The optional argument p can be used to pass additional parameters to the functions P and D.\n\nThe functions P and D can be used either in the out-of-place form with signature production_terms = P(u, p, t) or the in-place form P(production_terms, u, p, t).\n\nKeyword arguments:\n\np_prototype: If P is given in in-place form, p_prototype or copies thereof are used to store evaluations of P. If p_prototype is not specified explicitly and P is in-place, then p_prototype will be internally set to zeros(eltype(u0), (length(u0), length(u0))).\nanalytic: The analytic solution of a PDS must be given in the form f(u0,p,t). Specifying the analytic solution can be useful for plotting and convergence tests.\nstd_rhs: The standard ODE right-hand side evaluation function callable as du = std_rhs(u, p, t) for the out-of-place form and as std_rhs(du, u, p, t) for the in-place form. Solvers that do not rely on the production-destruction representation of the ODE, will use this function instead to compute the solution. If not specified, a default implementation calling P and D is used.\nlinear_invariants: The rows of this matrix contain the linear invariants of the ODE.  Certain solvers or callbacks require this matrix. Note that this feature is experimental and its API may change in future releases.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.prob_pds_bertolazzi","page":"API reference","title":"PositiveIntegrators.prob_pds_bertolazzi","text":"prob_pds_bertolazzi\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nmathbfu=beginpmatrix2 -1 -1-1 2 -1-1 -1 2endpmatrixbeginpmatrix5u_2u_3(10^-2 + (u_2u_3)^2) + u_2u_3(10^-16 + u_2u_3(10^-8 + u_2u_3))\n10u_1u_3^2\n01(u_3 - u_2 - 25)^2u_1u_2endpmatrix\nendaligned\n\nwith initial value mathbfu_0 = (00 10 20)^T and time domain (00 10). There is one independent linear invariant, e.g. u_1+u_2+u_3 = 30.\n\nReferences\n\nEnrico Bertolazzi. \"Positive and conservative schemes for mass action kinetics.\" Computers and Mathematics with Applications 32 (1996): 29-43. DOI: 10.1016/0898-1221(96)00142-3\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_brusselator","page":"API reference","title":"PositiveIntegrators.prob_pds_brusselator","text":"prob_pds_brusselator\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = -u_1\nu_2 = -u_2u_5\nu_3 = u_2u_5\nu_4 = u_5\nu_5 = u_1 - u_2u_5 + u_5^2u_6 - u_5\nu_6 = u_2u_5 - u_5^2u_6\nendaligned\n\nwith initial value mathbfu_0 = (100 100 00 00 01 01)^T and time domain (00 200). There are two independent linear invariants, e.g. u_1+u_4+u_5+u_6 = 102 and u_2+u_3 = 100.\n\nReferences\n\nLuca Bonaventura,  and Alessandro Della Rocca. \"Unconditionally Strong Stability Preserving Extensions of the TR-BDF2 Method.\" Journal of Scientific Computing 70 (2017): 859 - 895. DOI: 10.1007/s10915-016-0267-9\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_linmod","page":"API reference","title":"PositiveIntegrators.prob_pds_linmod","text":"prob_pds_linmod\n\nPositive and conservative autonomous linear PDS\n\nbeginaligned\nu_1 = u_2 - 5u_1\nu_2 = 5u_1 - u_2\nendaligned\n\nwith initial value mathbfu_0 = (09 01)^T and time domain (00 20). There is one independent linear invariant, e.g. u_1+u_2 = 1.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_linmod_inplace","page":"API reference","title":"PositiveIntegrators.prob_pds_linmod_inplace","text":"prob_pds_linmod_inplace\n\nSame as prob_pds_linmod but with in-place computation.\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_minmapk","page":"API reference","title":"PositiveIntegrators.prob_pds_minmapk","text":"prob_pds_minmapk\n\nPositive and nonconservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = k_6u_6-k_7u_1-k_1u_1u_2 +k_2u_4\nu_2 = k_5u_3-k_1u_2u_2\nu_3 = k_2u_4-k_3u_1u_3+k_4u_5-k_5u_3\nu_4 = k_1u_1u_2-k_2u_4\nu_5 = k_3u_1u_3-k_4u_5\nu_6 = k_7u_1-k_6u_6\nendaligned\n\nwith constants\n\nbeginaligned\nk_1 =frac1003  k_2 =frac13  k_3 =50\nk_4 =05  k_5 =frac103    k_6 = 01\nk_7 = 01\nendaligned\n\nThe initial value is mathbfu_0 = (01 0175 015 115 081 05)^T and the time domain (0 200). There are two independent linear invariants, e.g. u_1+u_4+u_6=175 and u_2+u_3+u_4+u_5 =2285.\n\nReferences\n\nSergio Blanes, Arieh Iserles, and Shev Macnamara. \"Positivity preserving methods for ordinary differential equations.\" ESAIM: Mathematical Modelling and Numerical Analysis 56 (2022): 1843–1870. DOI: 10.1051/m2an/2022042\nOtto Hadač, František Muzika, Vladislav Nevoral, Michal Přibyl, and Igor Schreiber \"Minimal oscillating subnetwork in the Huang-Ferrell model of the MAPK cascade.\" PLoS ONE 12 (2017): e0178457. DOI: 10.1371/journal.pone.0178457\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_nonlinmod","page":"API reference","title":"PositiveIntegrators.prob_pds_nonlinmod","text":"prob_pds_nonlinmod\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = -fracu_1u_2u_1 + 10\nu_2 = fracu_1u_2u_1 + 10 - 03u_2\nu_3 = 03 u_2\nendaligned\n\nwith initial value mathbfu_0 = (998 001 001)^T and time domain (00 300). There is one independent linear invariant, e.g. u_1+u_2+u_3 = 100.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_npzd","page":"API reference","title":"PositiveIntegrators.prob_pds_npzd","text":"prob_pds_npzd\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = 001u_2 + 001u_3 + 0003u_4 - fracu_1u_2001 + u_1\nu_2 = fracu_1u_2001 + u_1- 001u_2 - 05( 1 - e^-121u_2^2)u_3 - 005u_2\nu_3 = 05(1 - e^-121u_2^2)u_3 - 001u_3 - 002u_3\nu_4 = 005u_2 + 002u_3 - 0003u_4\nendaligned\n\nwith initial value mathbfu_0 = (80 20 10 40)^T and time domain (00 100). There is one independent linear invariant, e.g. u_1+u_2+u_3+u_4 = 150.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"Application of modified Patankar schemes to stiff biogeochemical models for the water column.\" Ocean Dynamics 55 (2005): 326-337. DOI: 10.1007/s10236-005-0001-x\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_robertson","page":"API reference","title":"PositiveIntegrators.prob_pds_robertson","text":"prob_pds_robertson\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = -004u_1+10^4 u_2u_3\nu_2 =  004u_1-10^4 u_2u_3-310^7 u_2^2\nu_3 = 310^7 u_2^2\nendaligned\n\nwith initial value mathbfu_0 = (10 00 00)^T and time domain (00 10^11). There is one independent linear invariant, e.g. u_1+u_2+u_3 = 10.\n\nReferences\n\nErnst Hairer, Gerd Wanner. \"Solving Ordinary Differential Equations II - Stiff and Differential-Algebraic Problems.\" 2nd Edition, Springer (2002): Section IV.1.\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_sir","page":"API reference","title":"PositiveIntegrators.prob_pds_sir","text":"prob_pds_sir\n\nPositive and conservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = -2u_1u_2\nu_2 = 2u_1u_2 - u_2\nu_3 = u_2\nendaligned\n\nwith initial value mathbfu_0 = (099 0005 0005)^T and time domain (00 200). There is one independent linear invariant, e.g. u_1+u_2+u_3 = 10.\n\nReferences\n\nRonald E. Mickens, and Talitha M. Washington. \"NSFD discretizations of interacting population models satisfying conservation laws.\" Computers and Mathematics with Applications 66 (2013): 2307-2316. DOI: 10.1016/j.camwa.2013.06.011\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_pds_stratreac","page":"API reference","title":"PositiveIntegrators.prob_pds_stratreac","text":"prob_pds_stratreac\n\nPositive and nonconservative autonomous nonlinear PDS\n\nbeginaligned\nu_1 = r_5 - r_6 -  r_7\nu_2 = 2r_1 - r_2 + r_3 - r_4 + r_6 - r_9 + r_10 - r_11\nu_3 = r_2 - r_3 - r_4 - r_5 - r_7 - r_8\nu_4 = -r_1 -r_2 + r_3 + 2r_4+r_5+2r_7+r_8+r_9\nu_5 = -r_8+r_9+r_10-r_11\nu_6 = r_8-r_9-r_10+r_11\nendaligned\n\nwith reaction rates\n\nbeginaligned\nr_1 =2643 10^-10σ^3 u_4  r_2 =801810^-17u_2 u_4   r_3 =61210^-4σ u_3\nr_4 =156710^-15u_3 u_2   r_5 = 107 10^-3σ^2u_3   r_6 = 71110^-11 81210^6 u_1\nr_7 = 1210^-10u_1 u_3  r_8 = 606210^-15u_3 u_5  r_9 = 106910^-11u_6 u_2\nr_10 = 128910^-2σ u_6  r_11 = 10^-8u_5 u_2\nendaligned\n\nwhere\n\nbeginaligned\nT = t3600 mod 24quad T_r=45quad T_s = 195\nσ(T) = begincases1  T_r T T_s0  textotherwiseendcases\nendaligned\n\nThe initial value is mathbfu_0 = (990610^1 662410^8 532610^11 169710^16 410^6 109310^9)^T and the time domain (432 10^4 302410^5). There are two independent linear invariants, e.g. u_1+u_2+3u_3+2u_4+u_5+2u_6=(113212)cdotmathbfu_0 and u_5+u_6 = 109710^9.\n\nReferences\n\nStephan Nüsslein, Hendrik Ranocha, and David I. Ketcheson. \"Positivity-preserving adaptive Runge-Kutta methods.\" Communications in Applied Mathematics and Computer Science 16 (2021): 155-179. DOI: 10.2140/camcos.2021.16.155\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.prob_ode_stratreac_scaled","page":"API reference","title":"PositiveIntegrators.prob_ode_stratreac_scaled","text":"prob_ode_stratreac_scaled\n\nScaled version of the stratosperic reaction problem prob_pds_stratreac. Each component is scaled by its corresponding original initial value.  \n\nThe initial value is mathbfu_0 = (111111)^T and the time domain (43210^4 302410^5).\n\nThere are two independent linear invariants. The function linear_invariants_stratreac_scaled returns the invariance matrix.\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/#PositiveIntegrators.MPE","page":"API reference","title":"PositiveIntegrators.MPE","text":"MPE([linsolve = ..., small_constant = ...])\n\nThe first-order modified Patankar-Euler algorithm for production-destruction systems. This one-step, one-stage method is first-order accurate, unconditionally positivity-preserving, and linearly implicit.\n\nThe scheme was introduced by Burchard et al. for conservative production-destruction systems. For nonconservative production–destruction systems we use the straight forward extension\n\nu_i^n+1 = u_i^n + Δt sum_j ji biggl(p_ij^n fracu_j^n+1u_j^n-d_ij^n fracu_i^n+1u_i^nbiggr) + Deltat p_ii^n - Δt d_ii^nfracu_i^n+1u_i^n,\n\nwhere p_ij^n = p_ij(t^nmathbf u^n) and d_ij^n = d_ij(t^nmathbf u^n).\n\nThe modified Patankar-Euler method requires the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to floatmin of the floating point type used.\n\nThe current implementation only supports fixed time steps.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.MPRK22","page":"API reference","title":"PositiveIntegrators.MPRK22","text":"MPRK22(α; [linsolve = ..., small_constant = ...])\n\nA family of second-order modified Patankar-Runge-Kutta algorithms for production-destruction systems. Each member of this family is an adaptive, one-step, two-stage method which is second-order accurate, unconditionally positivity-preserving, and linearly implicit. In this implementation the stage-values are conservative as well. The parameter α is described by Kopecz and Meister (2018) and studied by Izgin, Kopecz and Meister (2022) as well as Torlo, Öffner and Ranocha (2022).\n\nThis method supports adaptive time stepping, using the Patankar-weight denominators σ_i, see Kopecz and Meister (2018), as first order approximations to estimate the error.\n\nThe scheme was introduced by Kopecz and Meister for conservative production-destruction systems. For nonconservative production–destruction systems we use a straight forward extension analogous to MPE.\n\nThis modified Patankar-Runge-Kutta method requires the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to floatmin of the floating point type used.\n\nReferences\n\nHans Burchard, Eric Deleersnijder, and Andreas Meister. \"A high-order conservative Patankar-type discretisation for stiff systems of production-destruction equations.\" Applied Numerical Mathematics 47.1 (2003): 1-30. DOI: 10.1016/S0168-9274(03)00101-6\nStefan Kopecz and Andreas Meister. \"On order conditions for modified Patankar-Runge-Kutta schemes.\" Applied Numerical Mathematics 123 (2018): 159-179. DOI: 10.1016/j.apnum.2017.09.004\nThomas Izgin, Stefan Kopecz, and Andreas Meister. \"On Lyapunov stability of positive and conservative time integrators and application to second order modified Patankar-Runge-Kutta schemes.\" ESAIM: Mathematical Modelling and Numerical Analysis 56.3 (2022): 1053-1080. DOI: 10.1051/m2an/2022031\nDavide Torlo, Philipp Öffner, and Hendrik Ranocha. \"Issues with positivity-preserving Patankar-type schemes.\" Applied Numerical Mathematics 182 (2022): 117-147. DOI: 10.1016/j.apnum.2022.07.014\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.SSPMPRK22","page":"API reference","title":"PositiveIntegrators.SSPMPRK22","text":"SSPMPRK22(α, β; [linsolve = ..., small_constant = ...])\n\nA family of second-order modified Patankar-Runge-Kutta algorithms for production-destruction systems. Each member of this family is an adaptive, one-step, two-stage method which is second-order accurate, unconditionally positivity-preserving, and linearly implicit. The parameters α and β are described by Huang and Shu (2019) and studied by Huang, Izgin, Kopecz, Meister and Shu (2023). The difference to MPRK22 is that this method is based on the SSP formulation of an explicit second-order Runge-Kutta method. This family of schemes contains the MPRK22 family, where MPRK22(α) = SSMPRK22(0, α) applies.\n\nThis method supports adaptive time stepping, using the first order approximations (σ_i - u_i^n)  τ + u_i^n with τ=1+(α_21β_10^2)(β_20+β_21), see (2.7) in Huang and Shu (2019), to estimate the error.\n\nThe scheme was introduced by Huang and Shu for conservative production-destruction systems. For nonconservative production–destruction systems we use the straight forward extension analogous to MPE.\n\nThis modified Patankar-Runge-Kutta method requires the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to floatmin of the floating point type used.\n\nReferences\n\nJuntao Huang and Chi-Wang Shu. \"Positivity-Preserving Time Discretizations for Production–Destruction Equations with Applications to Non-equilibrium Flows.\" Journal of Scientific Computing 78 (2019): 1811–1839 DOI: 10.1007/s10915-018-0852-1\nJuntao Huang, Thomas Izgin, Stefan Kopecz, Andreas Meister and Chi-Wang Shu. \"On the stability of strong-stability-preserving modified Patankar-Runge-Kutta schemes.\" ESAIM: Mathematical Modelling and Numerical Analysis 57 (2023):1063–1086 DOI: 10.1051/m2an/2023005\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.MPRK43I","page":"API reference","title":"PositiveIntegrators.MPRK43I","text":"MPRK43I(α, β; [linsolve = ..., small_constant = ...])\n\nA family of third-order modified Patankar-Runge-Kutta schemes for production-destruction systems, which is based on the two-parameter family of third order explicit Runge–Kutta schemes. Each member of this family is an adaptive, one-step method with four-stages which is third-order accurate, unconditionally positivity-preserving, conservative and linearly implicit. In this implementation the stage-values are conservative as well. The parameters α and β must be chosen such that the Runge–Kutta coefficients are nonnegative, see Kopecz and Meister (2018) for details.\n\nThese methods support adaptive time stepping, using the Patankar-weight denominators σ_i, see Kopecz and Meister (2018), as second order approximations to estimate the error.\n\nThe scheme was introduced by Kopecz and Meister for conservative production-destruction systems. For nonconservative production–destruction systems we use the straight forward extension analogous to MPE.\n\nThese modified Patankar-Runge-Kutta methods require the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to floatmin of the floating point type used.\n\nReferences\n\nStefan Kopecz and Andreas Meister. \"Unconditionally positive and conservative third order modified Patankar–Runge–Kutta  discretizations of production–destruction systems.\"  BIT Numerical Mathematics 58 (2018): 691–728. DOI: 10.1007/s10543-018-0705-1\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.MPRK43II","page":"API reference","title":"PositiveIntegrators.MPRK43II","text":"MPRK43II(γ; [linsolve = ..., small_constant = ...])\n\nA family of third-order modified Patankar-Runge-Kutta schemes for production-destruction systems, which is based on the one-parameter family of third order explicit Runge–Kutta schemes with non-negative Runge–Kutta coefficients. Each member of this family is an adaptive, one-step method with four stages which is third-order accurate, unconditionally positivity-preserving, conservative and linearly implicit. In this implementation the stage-values are conservative as well. The parameter γ must satisfy 3/8 ≤ γ ≤ 3/4. Further details are given in Kopecz and Meister (2018).\n\nThis method supports adaptive time stepping, using the Patankar-weight denominators σ_i, see Kopecz and Meister (2018), as second order approximations to estimate the error.\n\nThe scheme was introduced by Kopecz and Meister for conservative production-destruction systems. For nonconservative production–destruction systems we use the straight forward extension analogous to MPE.\n\nThese modified Patankar-Runge-Kutta methods require the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. To display the default value for data type type evaluate MPRK43II(gamma).small_constant_function(type), where type can be, e.g., Float64.\n\nReferences\n\nStefan Kopecz and Andreas Meister. \"Unconditionally positive and conservative third order modified Patankar–Runge–Kutta  discretizations of production–destruction systems.\"  BIT Numerical Mathematics 58 (2018): 691–728. DOI: 10.1007/s10543-018-0705-1\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.SSPMPRK43","page":"API reference","title":"PositiveIntegrators.SSPMPRK43","text":"SSPMPRK43([linsolve = ..., small_constant = ...])\n\nA third-order modified Patankar-Runge-Kutta algorithm for production-destruction systems. This scheme is a one-step, four-stage method which is third-order accurate, unconditionally positivity-preserving, and linearly implicit. The scheme is described by Huang, Zhao and Shu (2019) and studied by Huang, Izgin, Kopecz, Meister and Shu (2023). The difference to MPRK43I or MPRK43II is that this method is based on the SSP formulation of an explicit third-order Runge-Kutta method.\n\nThe scheme was introduced by Huang, Zhao and Shu for conservative production-destruction systems. For nonconservative production–destruction systems we use the straight forward extension analogous to MPE.\n\nThis modified Patankar-Runge-Kutta method requires the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. To display the default value for data type type evaluate SSPMPRK43. small_constant_function(type), where type can be, e.g., Float64.\n\nThe current implementation only supports fixed time steps.\n\nReferences\n\nJuntao Huang, Weifeng Zhao and Chi-Wang Shu. \"A Third-Order Unconditionally Positivity-Preserving Scheme for Production–Destruction Equations with Applications to Non-equilibrium Flows.\" Journal of Scientific Computing 79 (2019): 1015–1056 DOI: 10.1007/s10915-018-0881-9\nJuntao Huang, Thomas Izgin, Stefan Kopecz, Andreas Meister and Chi-Wang Shu. \"On the stability of strong-stability-preserving modified Patankar-Runge-Kutta schemes.\" ESAIM: Mathematical Modelling and Numerical Analysis 57 (2023):1063–1086 DOI: 10.1051/m2an/2023005\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.MPDeC","page":"API reference","title":"PositiveIntegrators.MPDeC","text":"MPDeC(K; [nodes = :gausslobatto, linsolve = ..., small_constant = ...])\n\nA family of arbitrary order modified Patankar-Runge-Kutta algorithms for production-destruction systems. Each member of this family is an adaptive, one-step method which is Kth order accurate, unconditionally positivity-preserving, and linearly implicit. The integer K must be chosen to satisfy 2 ≤ K ≤ 10. Available node choices are Lagrange or Gauss-Lobatto nodes, with the latter being the default. These methods support adaptive time stepping, using the numerical solution obtained with one correction step less as a lower-order approximation to estimate the error. The MPDeC schemes were introduced by Torlo and Öffner (2020) for autonomous conservative production-destruction systems and further investigated in Torlo, Öffner and Ranocha (2022).\n\nFor nonconservative production–destruction systems we use a straight forward extension analogous to MPE. A general discussion of DeC schemes applied to non-autonomous differential equations and using general integration nodes is given by Ong and Spiteri (2020).\n\nThe MPDeC methods require the special structure of a PDSProblem or a ConservativePDSProblem.\n\nYou can optionally choose the linear solver to be used by passing an algorithm from LinearSolve.jl as keyword argument linsolve. You can also choose the parameter small_constant which is added to all Patankar-weight denominators to avoid divisions by zero. You can pass a value explicitly, otherwise small_constant is set to 1e-300 in double precision computations or floatmin of the floating point type used.\n\nReferences\n\nDavide Torlo and Philipp Öffner. \"Arbitrary high-order, conservative and positivity preserving Patankar-type deferred correction schemes.\" Applied Numerical Mathematics 153 (2020): 15-34. DOI: 10.1016/j.apnum.2020.01.025\nDavide Torlo, Philipp Öffner, and Hendrik Ranocha. \"Issues with positivity-preserving Patankar-type schemes.\" Applied Numerical Mathematics 182 (2022): 117-147. DOI: 10.1016/j.apnum.2022.07.014\nBenjamin W. Ong and Raymond J. Spiteri. \"Deferred Correction Methods for Ordinary Differential Equations.\" Journal of Scientific Computing 83 (2020): Article 60. DOI: 10.1007/s10915-020-01235-8\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.SanduProjection","page":"API reference","title":"PositiveIntegrators.SanduProjection","text":"SanduProjection(model, AT, b, eps = nothing; [save = true, verbose = false])\n\nA projection method which ensures conservation of prescribed linear invariants and positivity. If the current approximation mathbfu has negative components then a projection mathbfz is computed such that\n\nmin lVert mathbfz - mathbfu rVert_mathbfGquad mathbfA^Tmathbfz=mathbfbquad mathbfz mathbf0\n\nis satisfied, where the matrix mathbfA^T and the vector mathbfb define the linear invariants. The G-norm is defined by lVert mathbfurVert_mathbfG = sqrtmathbfu^TmathbfGmathbfu, and assuming mathbfu = (u_1dots u_s)^T, the positive definite diagonal matrix mathbfG is given by\n\nmathbfG(mathbfu)=operatornamediagbiggl(frac1s(mathttabstol+mathttreltollvert u_i rvert^2)biggr)\n\nwhere abstol and reltol denote the absolute and relative tolerances of the adaptive step size control, respectively. See Sandu (2001) for details.\n\nTo use this callback one must also specify save_everystep = false.\n\nArguments\n\nmodel: A JuMP Model to solve the minimization problem.\nAT: The matrix mathbfA^T defining the linear invariants.\nb: The vector mathbfb defining the linear invariants.\neps: It may be helpful for the optimization solver that feasible solutions are bounded away from 0. To achieve this one can specify the optional parameter eps. The positivity constraint is then replaced by mathbfzeps, where eps can either be a scalar or a vector. \n\nKeyword Arguments\n\nsave: If the keyword argument save is set to false only the initial value and the last approximation will be saved.         The default value is true.\nverbose: Enables additional output of the optimization solver. The default value is false.\n\nReferences\n\nAdrian Sandu. \"Positive numerical integration methods for chemical kinetic systems.\" Journal of Computational Physics 170 (2001): 589-602. DOI: 10.1006/jcph.2001.6750\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#PositiveIntegrators.isnegative","page":"API reference","title":"PositiveIntegrators.isnegative","text":"isnegative(sol::ODESolution)\n\nReturns true if sol.u contains negative elements.\n\nPlease note that negative values may occur when plotting the solution, depending on the interpolation used.\n\nSee also isnonnegative.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.isnonnegative","page":"API reference","title":"PositiveIntegrators.isnonnegative","text":"isnonnegative(u)\n\nNegation of isnegative.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.rel_max_error_tend","page":"API reference","title":"PositiveIntegrators.rel_max_error_tend","text":"rel_max_error_tend(sol, ref_sol)\n\nReturns the relative maximum error between sol and ref_sol at time sol.t[end].\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.rel_max_error_overall","page":"API reference","title":"PositiveIntegrators.rel_max_error_overall","text":"rel_max_error_overall(sol, ref_sol)\n\nReturns the maximum of the relative maximum errors between sol and ref_sol over all time steps.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.rel_l1_error_tend","page":"API reference","title":"PositiveIntegrators.rel_l1_error_tend","text":"rel_l1_error_tend(sol, ref_sol)\n\nReturns the relative l1 error between sol and ref_sol at time sol.t[end].\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.rel_l2_error_tend","page":"API reference","title":"PositiveIntegrators.rel_l2_error_tend","text":"rel_l2_error_tend(sol, ref_sol)\n\nReturns the relative l2 error between sol and ref_sol at time sol.t[end].\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.work_precision_adaptive","page":"API reference","title":"PositiveIntegrators.work_precision_adaptive","text":"work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref;\n                        adaptive_ref = false,\n                        abstol_ref = 1e-14,\n                        reltol_ref = 1e-13,\n                        compute_error = rel_max_error_tend,\n                        seconds = 2,\n                        numruns = 20,\n                        kwargs...)\n\nReturns a dictionary to create work-precision diagrams. The problem prob is solved by each algorithm in algs for all tolerances defined in abstols and reltols. For the respective tolerances the error and computing time are stored in the dictionary. If the solve is not successful for the given tolerances, then (Inf, Inf) is stored in the dictionary. The strings in the array labels are used as keys of the dictionary. The reference solution used for error computations is computed with the algorithm alg_ref. Additional keyword arguments are passed on to solve.\n\nKeyword arguments:\n\nadaptive_ref: If true the refenerce solution is computed adaptively with tolerances abstol_ref and reltol_ref. Otherwise 10^5 steps are used.\nabstol_ref: See adaptive_ref.\nreltol_ref: See adaptive_ref.\ncompute_error(sol::ODESolution, ref_sol::ODESolution): A function to compute the error between sol and ref_sol.\nseconds: If the measured computing time of a single solve is larger than seconds, then this computing time is stored in the dictionary.\nnumruns: If the measured computing time of a single solve is less than or equal to seconds, then numruns solves are performed and the median of the respective computing times is stored in the dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.work_precision_adaptive!","page":"API reference","title":"PositiveIntegrators.work_precision_adaptive!","text":"work_precision_adaptive(prob, algs, labels, abstols, reltols, alg_ref;\n                        adaptive_ref = false,\n                        abstol_ref = 1e-14,\n                        reltol_ref = 1e-13,\n                        compute_error = rel_max_error_tend,\n                        seconds = 2,\n                        numruns = 20,\n                        kwargs...)\n\nAdds work-precision data to the dictionary dict, which was created with work_precion_fixed_adaptive. See work_precision_adaptive for the meaning of the inputs.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.work_precision_fixed","page":"API reference","title":"PositiveIntegrators.work_precision_fixed","text":"work_precision_fixed(prob, algs, labels, dts, alg_ref;\n                     compute_error = rel_max_error_tend,\n                     seconds = 2,\n                     numruns = 20)\n\nReturns a dictionary to create work-precision diagrams. The problem prob is solved by each algorithm in algs for all the step sizes defined in dts. For each step size the error and computing time are stored in the dictionary. If the solve is not successful for a given step size, then (Inf, Inf) is stored in the dictionary. The strings in the array labels are used as keys of the dictionary. The reference solution used for error computations is computed with the algorithm alg_ref.\n\nKeyword arguments:\n\ncompute_error(sol::ODESolution, ref_sol::ODESolution): Function to compute the error between sol and ref_sol.\nseconds: If the measured computing time of a single solve is larger than seconds, then this computing time is stored in the dictionary.\nnumruns: If the measured computing time of a single solve is less than or equal to seconds, then numruns solves are performed and the median of the respective computing times is stored in the dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.work_precision_fixed!","page":"API reference","title":"PositiveIntegrators.work_precision_fixed!","text":"work_precision_fixed!(dict, prob, algs, labels, dts, alg_ref;\n                      compute_error = rel_max_error_tend,\n                      seconds = 2,\n                      numruns = 20)\n)\n\nAdds work-precision data to the dictionary dict, which was created with work_precion_fixed. See work_precision_fixed for the meaning of the inputs.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PositiveIntegrators.get_numsteps_SanduProjection","page":"API reference","title":"PositiveIntegrators.get_numsteps_SanduProjection","text":"get_numsteps_SanduProjection(proj)\n\nFor a SanduProjection proj, this function returns the number of the performed projection steps.\n\n\n\n\n\n","category":"function"},{"location":"license/#License","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2023-present Stefan Kopecz, Hendrik Ranocha, and contributorsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"section"},{"location":"sandu_projection/#tutorial-sandu","page":"Sandu Projection","title":"Tutorial: Positive-projection method","text":"This tutorial is about solving an ODE using the projection method introduced by Adrian Sandu in Positive Numerical Integration Methods for Chemical Kinetic Systems. It guarantees positivity by solving an optimization problem while preserving all linear invariants.\n\nThe Sandu projection is a post-processing technique that can be used in combination with any ODE solver. If the ODE solver computes a negative approximation at any time step, the projection method calculates a positive approximation, also taking into account the linear invariants.","category":"section"},{"location":"sandu_projection/#Solution-of-the-ODE-system","page":"Sandu Projection","title":"Solution of the ODE system","text":"As an example we want to the solve the NPZD problem prob_pds_npzd, which is an ODE system in which negative approximations quickly lead to unacceptable solutions. First, we solve the problem without Sandu projection and select ROS2 form OrdinaryDiffEq.jl as ODE solver.\n\nusing PositiveIntegrators\nusing OrdinaryDiffEqRosenbrock\nusing Plots\n\nprob = prob_pds_npzd\n\nref_sol = solve(prob, ROS2(); abstol = 1e-8, reltol = 1e-6); # reference solution for plotting\n\nsol = solve(prob, ROS2(); abstol = 5e-2, reltol = 1e-1)\n\nplot(ref_sol, linestyle = :dash, label = \"\", color = palette(:default)[1:4]')\nplot!(sol, ylims = (-2.5, 12.5), denseplot = false,  markers = :circle, linewidth = 2, color = palette(:default)[1:4]', label = [\"N\" \"P\" \"Z\" \"D\"], legend = :right)\n\nThe plot shows the numerical solution obtained with ROS2 compared to a reference solution (dashed lines). We see that the ROS2 method produces negative approximations, which can occur because Rosenbrock methods are not positivity-preserving. For the NPZD problem, however, this is fatal and leads to a completely unacceptable numerical solution. It is therefore particularly important to use techniques that guarantee positivity of the numerical approximations for this problem. We achieve this below with the SanduProjection.\n\nTo apply the SanduProjection we need to choose an optimization solver which is supported by JuMP.jl and can handle quadratic optimization problems (QP). In this tutorial we select Clarabel.jl as optimization solver.\n\nIn addition, we need to specify the linear invariants of the problem.  The only linear invariant of the NPZD problem is N(t)+P(t)+Z(t)+D(t)=N(0)+P(0)+Z(0)+D(0)=15 for all times t0. This can be written in the form \n\nmathbfA^T beginpmatrix N(t) P(t) Z(t) D(t) endpmatrix = mathbfb\n\nwith mathbfA^T = 10  10  10  10 and mathbfb = 15.\n\nThe projection method SanduProjection is implemented as a callback and hence, must be passed as an argument to the keyword callback. In addition, we must also use save_everystep = false.\n\nusing JuMP, Clarabel\n\nAT = [1.0 1.0 1.0 1.0]\nb = [15.0]\nproj = SanduProjection(Model(Clarabel.Optimizer), AT, b)\n\nsol_proj = solve(prob, ROS2(); abstol = 5e-2, reltol = 1e-1,\n                 save_everystep = false, callback = proj);\n\nplot(ref_sol, linestyle = :dash, label = \"\", color = palette(:default)[1:4]')\nplot!(sol_proj, ylims = (-2.5, 12.5), denseplot = false,  markers = :circle, linewidth = 2, color = palette(:default)[1:4]', label = [\"N\" \"P\" \"Z\" \"D\"], legend = :right)            \n\nAs intended, negative approximations no longer occur and we obtain an acceptable approximation.\n\nThe SanduProjection is implemented as a DiscreteCallback and we can display the number of projection steps in the following way.\n\n@show get_numsteps_SanduProjection(proj) \n\nWe can see that in this example, a single projection step was already sufficient.","category":"section"},{"location":"sandu_projection/#Package-versions","page":"Sandu Projection","title":"Package versions","text":"These results were obtained using the following versions.\n\nusing InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"JuMP\", \"Clarabel\", \"OrdinaryDiffEqRosenbrock\", \"Plots\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"section"},{"location":"scalar_pds/#tutorial-scalar-pds","page":"Scalar equation","title":"Tutorial: Solving a scalar production-destruction equation with MPRK schemes","text":"Originally, modified Patankar-Runge-Kutta (MPRK) schemes were designed to solve positive and conservative systems of ordinary differential equations. The conservation property requires that the system consists of at least two scalar differential equations. Nevertheless, we can also apply the idea of the Patankar trick to a scalar production-destruction system (PDS)\n\nu(t)=p(u(t))-d(u(t))quad u(0)=u_00\n\nwith nonnegative functions p and d. Since conservation is not an issue here, we can apply the Patankar trick to the destruction term d to ensure positivity and leave the production term p unweighted. A first-order scheme of this type, based on the forward Euler method, reads\n\nu^n+1= u^n + Δ t p(u^n) - Δ t d(u^n)fracu^n+1u^n\n\nand this idea can easily be generalized to higher-order explicit Runge-Kutta schemes.\n\nBy closer inspection we realize that this is exactly the approach the MPRK schemes of PositiveIntegrators.jl use to solve non-conservative PDS for which the production matrix is diagonal. Hence, we can use the existing schemes to solve a scalar PDS by regarding the production term as a 11-matrix and the destruction term as a 1-vector.","category":"section"},{"location":"scalar_pds/#scalar-example-1","page":"Scalar equation","title":"Example 1","text":"We want to solve\n\nu =  u^2 - uquad u(0) = 095\n\nfor 0 t 10. Here,  we can choose p(u)=u^2 as production term and d(u)=u as destruction term. The exact solution of this problem is\n\nu(t) = frac1919+e^t\n\nNext, we show how to solve this scalar PDS in the way discussed above. Please note that we must use PDSProblem to create the problem. Furthermore, we use static matrices and vectors from StaticArrays.jl instead of standard arrays for efficiency.\n\nusing PositiveIntegrators, StaticArrays, Plots\n\nu0 = @SVector [0.95] # 1-vector\ntspan = (0.0, 10.0)\n\n# Attention: Input u is a 1-vector\nprod(u, p, t) = @SMatrix [u[1]^2] # create static 1x1-matrix\ndest(u, p, t) = @SVector [u[1]] # create static 1-vector\nprob = PDSProblem(prod, dest, u0, tspan)\n\nsol = solve(prob, MPRK22(1.0))\n\n# plot\ntt = 0:0.1:10\nf(t) = 19.0 / (19.0 + exp(t)) # exact solution\nplot(tt, f.(tt), label=\"exact\")\nplot!(sol, label=\"u\")","category":"section"},{"location":"scalar_pds/#[Example-2]-(@id-scalar-example-2)","page":"Scalar equation","title":"[Example 2] (@id scalar-example-2)","text":"Next, we want to compute positive solutions of a more challenging scalar PDS. In Example 1, we could have also used standard schemes from OrdinaryDiffEq.jl and use the solver option isoutofdomain to ensure positivity. But this is not always the case as the following example will show.\n\nWe want to compute the nonnegative solution of\n\nu(t) = -sqrtlvert u(t)rvert quad u(0)=1\n\nfor t 0. Please note that this initial value problem has infinitely many solutions\n\nu(t) = begincases frac14(t-2)^2  0 t 2 0  2 t  t^* -frac14(t-2)^2  t^*  t endcases\n\nwhere t^* 2 is arbitrary. But among these, the only nonnegative solution is\n\nu(t) = begincases frac14(t-2)^2  0 t 2 0  2 t endcases\n\nThis is the solution we want to compute.\n\nFirst, we try this using a standard solver from OrdinaryDiffEq.jl. We try to enforce positivity with the solver option isoutofdomain by specifying that negative solution components are not acceptable.\n\nusing OrdinaryDiffEqRosenbrock\n\ntspan = (0.0, 3.0)\nu0 = 1.0\n\nf(u, p, t) = -sqrt(abs(u))\nprob = ODEProblem(f, u0, tspan)\n\nsol = solve(prob, Rosenbrock23(); isoutofdomain = (u, p, t) -> any(<(0), u))\n\nWe see that isoutofdomain cannot be used to ensure nonnegative solutions in this case, as the computation stops at about t 2 before the desired final time is reached. For at least first- and second-order explicit Runge-Kutta schemes, this can also be shown analytically. A brief computation reveals that to ensure nonnegative solutions, the time step size must tend to zero if the numerical solution tends to zero.\n\nNext, we want to use an MPRK scheme. We can choose p(u)=0 as the production term and d(u)=sqrtlvert urvert  as the destruction term. Furthermore, we create the PDSProblem in the same way as in Example 1.\n\nusing PositiveIntegrators, StaticArrays, Plots\n\ntspan = (0.0, 3.0)\nu0 = @SVector [1.0]\n\nprod(u, p, t) = @SMatrix zeros(1,1)\ndest(u, p, t) = @SVector [sqrt(abs(first(u)))]\nprob = PDSProblem(prod, dest, u0, tspan)\n\nsol = solve(prob, MPRK22(1.0))\n\n# plot\ntt = 0:0.03:3\nf(t) = 0.25 * (t - 2)^2 * (t <= 2) # exact solution\nplot(tt, f.(tt), label=\"exact\")\nplot!(sol, label=\"u\")\n\nWe can see that the MPRK scheme used is well suited to solve the problem.","category":"section"},{"location":"scalar_pds/#Package-versions","page":"Scalar equation","title":"Package versions","text":"These results were obtained using the following versions.\n\nusing InteractiveUtils\nversioninfo()\nprintln()\n\nusing Pkg\nPkg.status([\"PositiveIntegrators\", \"StaticArrays\", \"OrdinaryDiffEqRosenbrock\"],\n           mode = PKGMODE_MANIFEST)\nnothing # hide","category":"section"},{"location":"#PositiveIntegrators.jl","page":"Home","title":"PositiveIntegrators.jl","text":"The Julia library PositiveIntegrators.jl provides several time integration methods developed to preserve the positivity of numerical solutions.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"PositiveIntegrators.jl is a registered Julia package. Thus, you can install it from the Julia REPL via\n\njulia> using Pkg; Pkg.add(\"PositiveIntegrators\")\n\nIf you want to update PositiveIntegrators.jl, you can use\n\njulia> using Pkg; Pkg.update(\"PositiveIntegrators\")\n\nAs usual, if you want to update PositiveIntegrators.jl and all other packages in your current project, you can execute\n\njulia> using Pkg; Pkg.update()","category":"section"},{"location":"#Basic-examples","page":"Home","title":"Basic examples","text":"","category":"section"},{"location":"#Modified-Patankar-Runge-Kutta-schemes","page":"Home","title":"Modified Patankar-Runge-Kutta schemes","text":"Modified Patankar-Runge-Kutta (MPRK) schemes are unconditionally positive and conservative time integration schemes for the solution of positive and conservative ODE systems. The application of these methods is based on the representation of the ODE system as a so-called production-destruction system (PDS).","category":"section"},{"location":"#Production-destruction-systems-(PDS)","page":"Home","title":"Production-destruction systems (PDS)","text":"The application of MPRK schemes requires the ODE system to be represented as a production-destruction system (PDS). A PDS takes the general form\n\n    u_i(t) = sum_j=1^N bigl(p_ij(tboldsymbol u) - d_ij(tboldsymbol u)bigr)quad i=1dotsN\n\nwhere boldsymbol u=(u_1dotsu_N)^T is the vector of unknowns and both production terms p_ij(tboldsymbol u) and destruction terms d_ij(tboldsymbol u) must be nonnegative for all ij=1dotsN. The meaning behind p_ij and d_ij is as follows:\n\np_ij with ine j represents the sum of all nonnegative terms which appear in equation i with a positive sign and in equation j with a negative sign.\nd_ij with ine j represents the sum of all nonnegative terms which appear in equation i with a negative sign and in equation j with a positive sign.\np_ii represents the sum of all nonnegative terms  which appear in equation i and don't have a negative counterpart in one of the other equations.\nd_ii represents the sum of all negative terms which appear in equation i and don't have a positive counterpart in one of the other equations.\n\nThis naming convention leads to p_ij = d_ji for i j and therefore a PDS is completely defined by the production matrix mathbfP=(p_ij)_ij=1dotsN and the destruction vector mathbfd=(d_ii)_i=1dotsN.\n\nAs an example we consider the Lotka-Volterra model\n\nbeginaligned\nu_1 = 2u_1-u_1u_2\nu_2 = u_1u_2-u_2\nendaligned\n\nwhich always has positive solutions if positive initial values are supplied. Assuming u_1u_20, the above naming scheme results in\n\nbeginaligned\np_11(u_1u_2) = 2u_1\np_21(u_1u_2) = u_1u_2 = d_12(u_1u_2) \nd_22(u_1u_2) = u_2\nendaligned\n\nwhere all remaining production and destruction terms are zero. Consequently the production matrix mathbf P and destruction vector mathbf d are\n\nmathbf P(u_1u_2) = beginpmatrix2u_1  0 u_1u_2  0endpmatrixquad mathbf d(u_1u_2) = beginpmatrix0 u_2endpmatrix\n\nTo solve this PDS together with initial values u_1(0)=u_2(0)=2 on the time domain (010), we first need to create a PDSProblem.\n\nusing PositiveIntegrators # load PDSProblem\n\nP(u, p, t) = [2*u[1]  0; u[1]*u[2]  0] # Production matrix\nd(u, p, t) = [0; u[2]] # Destruction vector\n\nu0 = [2.0; 2.0] # initial values\ntspan = (0.0, 10.0) # time span\n\n# Create PDS\nprob = PDSProblem(P, d, u0, tspan)\nnothing #hide\n\nNow that the problem has been created, we can solve it with any method of PositiveIntegrators.jl. In the following, we use the method MPRK22(1.0). In addition, we could also use any method provided by OrdinaryDiffEq.jl, but these might possibly generate negative approximations.\n\nsol = solve(prob, MPRK22(1.0))\nnothing # hide\n\nFinally, we can use Plots.jl to visualize the solution.\n\nusing Plots\n\nplot(sol)","category":"section"},{"location":"#Conservative-production-destruction-systems","page":"Home","title":"Conservative production-destruction systems","text":"A PDS with the additional property\n\n  p_ii(tboldsymbol y)=d_ii(tboldsymbol y)=0\n\nfor i=1dotsN is called conservative. In this case we have p_ij=d_ji for all ij=1dotsN, which leads to\n\nfracddtsum_i=1^N y_i=sum_i=1^N y_i = sum_mathclapij=1^N bigl(p_ij(tboldsymbol y) - d_ij(tboldsymbol y)bigr)= sum_mathclapij=1^N bigl(p_ij(tboldsymbol y) - p_ji(tboldsymbol y)bigr) = 0\n\nThis shows that the sum of the state variables of a conservative PDS remains constant over time, i.e.\n\nsum_i=1^N y_i(t) = sum_i=1^N y_i(0)\n\nfor all times t0.\n\nOne specific example of a conservative PDS is the SIR model\n\nS = -fracβ S INquad I= fracβ S IN - γ Iquad R=γ I\n\nwith N=S+I+R and betagamma0. Assuming SIR0 the production and destruction terms are given by\n\np_21(SIR) = d_12(SIR) = fracβ S INquad p_32(SIR) = d_23(SIR) = γ I\n\nwhere the remaining production and destruction terms are zero. The corresponding production matrix mathbf P is\n\nmathbf P(SIR) = beginpmatrix0  0  0 fracβ S IN  0  0 0  γ I  0endpmatrix\n\nThe following example shows how to implement the above SIR model with beta=04 gamma=004, initial conditions S(0)=997 I(0)=3 R(0)=0 and time domain (0 100) using ConservativePDSProblem from PositiveIntegrators.jl.\n\nusing PositiveIntegrators\n\n# Out-of-place implementation of the P matrix for the SIR model\nfunction P(u, p, t)\n  S, I, R = u\n\n  β = 0.4\n  γ = 0.04\n  N = 1000.0\n\n  P = zeros(3,3)\n  P[2,1] = β*S*I/N\n  P[3,2] = γ*I\n  return P\nend\n\nu0 = [997.0; 3.0; 0.0]; # initial values\ntspan = (0.0, 100.0); # time span\n\n# Create SIR problem\nprob = ConservativePDSProblem(P, u0, tspan)\nnothing # hide\n\nSince the SIR model is not only conservative but also positive, we can use any scheme from PositiveIntegrators.jl to solve it. Here we use MPRK22(1.0). Please note that any method from OrdinaryDiffEq.jl can be used as well, but might possibly generate negative approximations.\n\nsol = solve(prob, MPRK22(1.0))\nnothing # hide\n\nFinally, we can use Plots.jl to visualize the solution.\n\nusing Plots\n\nplot(sol, label = [\"S\" \"I\" \"R\"], legend=:right)\nplot!(sol.t, sum.(sol.u), label = \"S+I+R\") # Plot S+I+R over time.\n\nWe see that there is always a nonnegative number of people in each compartment, while the population S+I+R remains constant over time.","category":"section"},{"location":"#Referencing","page":"Home","title":"Referencing","text":"If you use PositiveIntegrators.jl for your research, please cite our article \n\n@article{kopecz2025positive,\n  title={{PositiveIntegrators.jl}: A {J}ulia library of positivity-preserving\n         time integration methods},\n  author={Kopecz, Stefan and Lampert, Joshua and Ranocha, Hendrik},\n  journal={Journal of Open Source Software},\n  volume={10},\n  number={109},\n  pages={8130},\n  year={2025},\n  month={05},\n  publisher={The Open Journal},\n  doi={10.21105/joss.08130}\n}\n\nIn addition, you can also refer to PositiveIntegrators.jl directly as\n\n@misc{PositiveIntegrators.jl,\n  title={{PositiveIntegrators.jl}: {A} {J}ulia library of positivity-preserving\n         time integration methods},\n  author={Kopecz, Stefan and Lampert, Joshua and Ranocha, Hendrik},\n  year={2023},\n  doi={10.5281/zenodo.10868393},\n  url={https://github.com/NumericalMathematics/PositiveIntegrators.jl}\n}","category":"section"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"This project is licensed under the MIT license (see License). Since it is an open-source project, we are very happy to accept contributions from the community. Please refer to the section Contributing for more details.","category":"section"}]
}
